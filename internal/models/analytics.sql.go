// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package models

import (
	"context"
	"database/sql"
	"time"
)

const getAverageDeliveryDays = `-- name: GetAverageDeliveryDays :one

SELECT ROUND(AVG(EXTRACT(EPOCH
                         FROM (s.delivered_at - s.shipped_at))/86400), 2) AS avg_delivery_days
FROM shipment s
JOIN customer_order o ON o.order_id = s.order_id
WHERE o.store_id = $1
  AND s.delivered_at IS NOT NULL
`

func (q *Queries) GetAverageDeliveryDays(ctx context.Context, storeID int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getAverageDeliveryDays, storeID)
	var avg_delivery_days string
	err := row.Scan(&avg_delivery_days)
	return avg_delivery_days, err
}

const getCompletedOrders = `-- name: GetCompletedOrders :one

SELECT COUNT(*) AS completed_orders
FROM customer_order co
WHERE co.store_id = $1
  AND co.status = 'completed'
`

func (q *Queries) GetCompletedOrders(ctx context.Context, storeID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCompletedOrders, storeID)
	var completed_orders int64
	err := row.Scan(&completed_orders)
	return completed_orders, err
}

const getConversionOverTime = `-- name: GetConversionOverTime :many

SELECT DATE(vs.first_seen_at) AS DAY,
       ROUND(COUNT(DISTINCT co.session_id)::numeric / NULLIF(COUNT(DISTINCT vs.session_id), 0) * 100, 2) AS conversion_rate_percent
FROM visitor_session vs
LEFT JOIN customer_order co ON vs.session_id = co.session_id
AND co.created_at >= $2
AND co.created_at < $3
AND co.status = 'completed'
WHERE vs.store_id = $1
  AND vs.first_seen_at >= $2
  AND vs.first_seen_at < $3
GROUP BY DAY
ORDER BY DAY
`

type GetConversionOverTimeParams struct {
	StoreID     int64
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

type GetConversionOverTimeRow struct {
	Day                   time.Time
	ConversionRatePercent string
}

func (q *Queries) GetConversionOverTime(ctx context.Context, arg GetConversionOverTimeParams) ([]GetConversionOverTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, getConversionOverTime, arg.StoreID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversionOverTimeRow
	for rows.Next() {
		var i GetConversionOverTimeRow
		if err := rows.Scan(&i.Day, &i.ConversionRatePercent); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversionRate = `-- name: GetConversionRate :one

SELECT COUNT(DISTINCT co.order_id)::FLOAT / NULLIF(COUNT(DISTINCT vs.session_id), 0) AS conversion_rate
FROM visitor_session vs
LEFT JOIN customer_order co ON vs.customer_id = co.customer_id
AND co.store_id = $1
AND co.status = 'completed'
AND co.created_at BETWEEN $2 AND $3
WHERE vs.store_id = $1
  AND vs.first_seen_at BETWEEN $2 AND $3
`

type GetConversionRateParams struct {
	StoreID     int64
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

func (q *Queries) GetConversionRate(ctx context.Context, arg GetConversionRateParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getConversionRate, arg.StoreID, arg.CreatedAt, arg.CreatedAt_2)
	var conversion_rate int32
	err := row.Scan(&conversion_rate)
	return conversion_rate, err
}

const getCountOfLowAndOutOfStockProducts = `-- name: GetCountOfLowAndOutOfStockProducts :one

SELECT COUNT(*) AS low_out_stock_products
FROM product p
WHERE p.store_id = $1
  AND p.deleted_at IS NULL
  AND p.stock_quantity <= 10
`

func (q *Queries) GetCountOfLowAndOutOfStockProducts(ctx context.Context, storeID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCountOfLowAndOutOfStockProducts, storeID)
	var low_out_stock_products int64
	err := row.Scan(&low_out_stock_products)
	return low_out_stock_products, err
}

const getCountOfNewPurchasingCustomers = `-- name: GetCountOfNewPurchasingCustomers :one

SELECT COUNT(DISTINCT o.customer_id) AS new_buyers_count
FROM customer_order o
INNER JOIN payment p ON o.order_id = p.order_id
WHERE o.store_id = $1
  AND o.customer_id IS NOT NULL
  AND p.status = 'completed'
  AND p.created_at >= $2 

  AND p.created_at < $3 

  AND NOT EXISTS
    (SELECT 1
     FROM customer_order o_prev
     INNER JOIN payment p_prev ON o_prev.order_id = p_prev.order_id
     WHERE o_prev.customer_id = o.customer_id
       AND o_prev.store_id = o.store_id
       AND p_prev.status = 'completed'
       AND p_prev.created_at < $2 
)
`

type GetCountOfNewPurchasingCustomersParams struct {
	StoreID     int64
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

// Customers page
func (q *Queries) GetCountOfNewPurchasingCustomers(ctx context.Context, arg GetCountOfNewPurchasingCustomersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCountOfNewPurchasingCustomers, arg.StoreID, arg.CreatedAt, arg.CreatedAt_2)
	var new_buyers_count int64
	err := row.Scan(&new_buyers_count)
	return new_buyers_count, err
}

const getCustomersGrowthPercent = `-- name: GetCustomersGrowthPercent :one
WITH current_period AS
  (SELECT COUNT(*) AS cnt
   FROM customer c
   WHERE c.store_id = $1
     AND c.created_at >= $2
     AND c.created_at < $3),
     previous_period AS
  (SELECT COUNT(*) AS cnt
   FROM customer c
   WHERE c.store_id = $1
     AND c.created_at >= ($2 - ($3 - $2))
     AND c.created_at < $2)
SELECT CASE
           WHEN previous_period.cnt = 0 THEN NULL
           ELSE ROUND(((current_period.cnt - previous_period.cnt)::numeric / previous_period.cnt) * 100, 2)
       END AS growth_percentage
FROM current_period,
     previous_period
`

type GetCustomersGrowthPercentParams struct {
	StoreID     int64
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

// Customers page
func (q *Queries) GetCustomersGrowthPercent(ctx context.Context, arg GetCustomersGrowthPercentParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getCustomersGrowthPercent, arg.StoreID, arg.CreatedAt, arg.CreatedAt_2)
	var growth_percentage interface{}
	err := row.Scan(&growth_percentage)
	return growth_percentage, err
}

const getFunnelMetrics = `-- name: GetFunnelMetrics :one
WITH visits AS
  (SELECT vs.session_id
   FROM visitor_session vs
   WHERE vs.store_id = $1
     AND vs.first_seen_at BETWEEN $2 AND $3),
     product_views AS
  (SELECT DISTINCT pv.session_id
   FROM product_view pv
   JOIN visits v ON v.session_id = pv.session_id),
     added_to_cart AS
  (SELECT DISTINCT ce.session_id
   FROM cart_event ce
   JOIN product_views pv ON pv.session_id = ce.session_id
   WHERE ce.event_type = 'add'),
     checkout_started AS
  (SELECT DISTINCT co.session_id
   FROM customer_order co
   JOIN added_to_cart ac ON ac.session_id = co.session_id
   WHERE co.created_at BETWEEN $2 AND $3),
     purchase_complete AS
  (SELECT DISTINCT co.session_id
   FROM customer_order co
   JOIN checkout_started cs ON cs.session_id = co.session_id
   WHERE co.status = 'completed'
     AND co.created_at BETWEEN $2 AND $3)
SELECT
  (SELECT COUNT(*)
   FROM visits) AS site_visits,

  (SELECT COUNT(*)
   FROM product_views) AS product_views,

  (SELECT COUNT(*)
   FROM added_to_cart) AS added_to_cart,

  (SELECT COUNT(*)
   FROM checkout_started) AS checkout_started,

  (SELECT COUNT(*)
   FROM purchase_complete) AS purchase_complete,
       ROUND((
                (SELECT COUNT(*)
                 FROM visits) -
                (SELECT COUNT(*)
                 FROM product_views))::numeric / NULLIF(
                                                          (SELECT COUNT(*)
                                                           FROM visits),0) * 100, 2) AS drop_site_to_view_pct,
       ROUND((
                (SELECT COUNT(*)
                 FROM product_views) -
                (SELECT COUNT(*)
                 FROM added_to_cart))::numeric / NULLIF(
                                                          (SELECT COUNT(*)
                                                           FROM product_views),0) * 100, 2) AS drop_view_to_cart_pct,
       ROUND((
                (SELECT COUNT(*)
                 FROM added_to_cart) -
                (SELECT COUNT(*)
                 FROM checkout_started))::numeric / NULLIF(
                                                             (SELECT COUNT(*)
                                                              FROM added_to_cart),0) * 100, 2) AS drop_cart_to_checkout_pct,
       ROUND((
                (SELECT COUNT(*)
                 FROM checkout_started) -
                (SELECT COUNT(*)
                 FROM purchase_complete))::numeric / NULLIF(
                                                              (SELECT COUNT(*)
                                                               FROM checkout_started),0) * 100, 2) AS drop_checkout_to_purchase_pct
`

type GetFunnelMetricsParams struct {
	StoreID       int64
	FirstSeenAt   sql.NullTime
	FirstSeenAt_2 sql.NullTime
}

type GetFunnelMetricsRow struct {
	SiteVisits                int64
	ProductViews              int64
	AddedToCart               int64
	CheckoutStarted           int64
	PurchaseComplete          int64
	DropSiteToViewPct         string
	DropViewToCartPct         string
	DropCartToCheckoutPct     string
	DropCheckoutToPurchasePct string
}

func (q *Queries) GetFunnelMetrics(ctx context.Context, arg GetFunnelMetricsParams) (GetFunnelMetricsRow, error) {
	row := q.db.QueryRowContext(ctx, getFunnelMetrics, arg.StoreID, arg.FirstSeenAt, arg.FirstSeenAt_2)
	var i GetFunnelMetricsRow
	err := row.Scan(
		&i.SiteVisits,
		&i.ProductViews,
		&i.AddedToCart,
		&i.CheckoutStarted,
		&i.PurchaseComplete,
		&i.DropSiteToViewPct,
		&i.DropViewToCartPct,
		&i.DropCartToCheckoutPct,
		&i.DropCheckoutToPurchasePct,
	)
	return i, err
}

const getLoyalCustomers = `-- name: GetLoyalCustomers :many

SELECT c.name AS customer_name,
       SUM(co.total_amount) AS total_spent,
       COUNT(co.order_id) AS orders_count
FROM customer c
JOIN customer_order co ON c.customer_id = co.customer_id
WHERE co.store_id = $1
  AND co.created_at BETWEEN $2 AND $3
GROUP BY c.customer_id,
         c.name
ORDER BY orders_count DESC
LIMIT 5
`

type GetLoyalCustomersParams struct {
	StoreID     int64
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

type GetLoyalCustomersRow struct {
	CustomerName string
	TotalSpent   int64
	OrdersCount  int64
}

func (q *Queries) GetLoyalCustomers(ctx context.Context, arg GetLoyalCustomersParams) ([]GetLoyalCustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, getLoyalCustomers, arg.StoreID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLoyalCustomersRow
	for rows.Next() {
		var i GetLoyalCustomersRow
		if err := rows.Scan(&i.CustomerName, &i.TotalSpent, &i.OrdersCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewOrdersThisMonth = `-- name: GetNewOrdersThisMonth :one

SELECT COUNT(*) AS new_orders
FROM customer_order co
WHERE co.store_id = $1
  AND co.created_at >= $2
  AND co.created_at < $3
`

type GetNewOrdersThisMonthParams struct {
	StoreID     int64
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

// Overview page
func (q *Queries) GetNewOrdersThisMonth(ctx context.Context, arg GetNewOrdersThisMonthParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNewOrdersThisMonth, arg.StoreID, arg.CreatedAt, arg.CreatedAt_2)
	var new_orders int64
	err := row.Scan(&new_orders)
	return new_orders, err
}

const getNewRegisteredCustomers = `-- name: GetNewRegisteredCustomers :one

SELECT COUNT(*) AS new_customers
FROM customer c
WHERE c.store_id = $1
  AND c.created_at >= $2
  AND c.created_at < $3
`

type GetNewRegisteredCustomersParams struct {
	StoreID     int64
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

// Overview page
func (q *Queries) GetNewRegisteredCustomers(ctx context.Context, arg GetNewRegisteredCustomersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNewRegisteredCustomers, arg.StoreID, arg.CreatedAt, arg.CreatedAt_2)
	var new_customers int64
	err := row.Scan(&new_customers)
	return new_customers, err
}

const getNewVisitors = `-- name: GetNewVisitors :one

SELECT COUNT(DISTINCT vs.session_id) AS new_visitors
FROM visitor_session vs
WHERE vs.store_id = $1
  AND vs.first_seen_at >= $2
  AND vs.first_seen_at < $3
`

type GetNewVisitorsParams struct {
	StoreID       int64
	FirstSeenAt   sql.NullTime
	FirstSeenAt_2 sql.NullTime
}

func (q *Queries) GetNewVisitors(ctx context.Context, arg GetNewVisitorsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNewVisitors, arg.StoreID, arg.FirstSeenAt, arg.FirstSeenAt_2)
	var new_visitors int64
	err := row.Scan(&new_visitors)
	return new_visitors, err
}

const getOrdersGrowthPercent = `-- name: GetOrdersGrowthPercent :one
WITH current_period AS
  (SELECT COALESCE(COUNT(*), 0) AS orders_count
   FROM customer_order co
   WHERE co.store_id = $1
     AND co.status = 'completed'
     AND co.created_at >= $2
     AND co.created_at < $3),
     previous_period AS
  (SELECT COALESCE(COUNT(*), 0) AS orders_count
   FROM customer_order co
   WHERE co.store_id = $1
     AND co.status = 'completed'
     AND co.created_at >= ($2 - ($3 - $2))
     AND co.created_at < $2)
SELECT CASE
           WHEN previous_period.orders_count = 0 THEN NULL
           ELSE ROUND(((current_period.orders_count - previous_period.orders_count)::numeric / previous_period.orders_count) * 100, 2)
       END AS orders_growth_percent
FROM current_period,
     previous_period
`

type GetOrdersGrowthPercentParams struct {
	StoreID     int64
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

func (q *Queries) GetOrdersGrowthPercent(ctx context.Context, arg GetOrdersGrowthPercentParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getOrdersGrowthPercent, arg.StoreID, arg.CreatedAt, arg.CreatedAt_2)
	var orders_growth_percent interface{}
	err := row.Scan(&orders_growth_percent)
	return orders_growth_percent, err
}

const getPageViews = `-- name: GetPageViews :one

SELECT COUNT(pv.product_view_id) AS total_page_views
FROM product_view pv
WHERE pv.store_id = $1
  AND pv.viewed_at BETWEEN $2 AND $3
`

type GetPageViewsParams struct {
	StoreID    int64
	ViewedAt   sql.NullTime
	ViewedAt_2 sql.NullTime
}

func (q *Queries) GetPageViews(ctx context.Context, arg GetPageViewsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPageViews, arg.StoreID, arg.ViewedAt, arg.ViewedAt_2)
	var total_page_views int64
	err := row.Scan(&total_page_views)
	return total_page_views, err
}

const getPendingOrders = `-- name: GetPendingOrders :one

SELECT COUNT(*) AS pending_orders
FROM customer_order co
WHERE co.store_id = $1
  AND co.status = 'pending'
`

func (q *Queries) GetPendingOrders(ctx context.Context, storeID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPendingOrders, storeID)
	var pending_orders int64
	err := row.Scan(&pending_orders)
	return pending_orders, err
}

const getPopularButNotSellingProducts = `-- name: GetPopularButNotSellingProducts :many
WITH views AS (
    SELECT
        pv.product_id,
        COUNT(*) AS views
    FROM product_view pv
    WHERE pv.store_id = $1
      AND pv.viewed_at BETWEEN $2 AND $3
    GROUP BY pv.product_id
),
sales AS (
    SELECT
        product_variant.product_id,
        COUNT(DISTINCT customer_order.order_id) AS sales_count
    FROM product_variant
    JOIN order_item
      ON order_item.variant_id = product_variant.variant_id
    JOIN customer_order
      ON customer_order.order_id = order_item.order_id
    WHERE product_variant.store_id = $1
      AND customer_order.status = 'completed'
      AND customer_order.created_at BETWEEN $2 AND $3
    GROUP BY product_variant.product_id
)
SELECT
    views.product_id,
    views.views,
    COALESCE(sales.sales_count, 0) AS sales_count
FROM views
LEFT JOIN sales
  ON sales.product_id = views.product_id
WHERE COALESCE(sales.sales_count, 0) = 0
ORDER BY views.views DESC
`

type GetPopularButNotSellingProductsParams struct {
	StoreID    int64
	ViewedAt   sql.NullTime
	ViewedAt_2 sql.NullTime
}

type GetPopularButNotSellingProductsRow struct {
	ProductID  int64
	Views      int64
	SalesCount int64
}

func (q *Queries) GetPopularButNotSellingProducts(ctx context.Context, arg GetPopularButNotSellingProductsParams) ([]GetPopularButNotSellingProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPopularButNotSellingProducts, arg.StoreID, arg.ViewedAt, arg.ViewedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPopularButNotSellingProductsRow
	for rows.Next() {
		var i GetPopularButNotSellingProductsRow
		if err := rows.Scan(&i.ProductID, &i.Views, &i.SalesCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsNeedingAttention = `-- name: GetProductsNeedingAttention :many
WITH product_sales AS
  (SELECT pv.product_id,
          COALESCE(SUM(oi.quantity), 0) AS units_sold,
          COALESCE(SUM(oi.subtotal), 0) AS revenue
   FROM product_variant pv
   LEFT JOIN order_item oi ON pv.variant_id = oi.variant_id
   LEFT JOIN customer_order co ON oi.order_id = co.order_id
   AND co.store_id = $1
   AND co.created_at BETWEEN $2 AND $3
   WHERE pv.store_id = $1
   GROUP BY pv.product_id)
SELECT p.name AS product_name,
       s.units_sold,
       s.revenue
FROM product p
LEFT JOIN product_sales s ON p.product_id = s.product_id
WHERE p.store_id = $1
ORDER BY s.units_sold ASC,
         s.revenue ASC
LIMIT 5
`

type GetProductsNeedingAttentionParams struct {
	StoreID     int64
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

type GetProductsNeedingAttentionRow struct {
	ProductName string
	UnitsSold   interface{}
	Revenue     interface{}
}

func (q *Queries) GetProductsNeedingAttention(ctx context.Context, arg GetProductsNeedingAttentionParams) ([]GetProductsNeedingAttentionRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsNeedingAttention, arg.StoreID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsNeedingAttentionRow
	for rows.Next() {
		var i GetProductsNeedingAttentionRow
		if err := rows.Scan(&i.ProductName, &i.UnitsSold, &i.Revenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchasingCustomers = `-- name: GetPurchasingCustomers :one

SELECT COUNT(DISTINCT co.customer_id) AS purchasing_customers
FROM customer_order co
WHERE co.store_id = $1
  AND co.status = 'completed'
  AND co.customer_id IS NOT NULL
`

func (q *Queries) GetPurchasingCustomers(ctx context.Context, storeID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPurchasingCustomers, storeID)
	var purchasing_customers int64
	err := row.Scan(&purchasing_customers)
	return purchasing_customers, err
}

const getPurchasingCustomersGrowthPercent = `-- name: GetPurchasingCustomersGrowthPercent :one
WITH current_period AS
  (SELECT COUNT(DISTINCT o.customer_id) AS cnt
   FROM customer_order o
   JOIN payment p ON o.order_id = p.order_id
   WHERE o.store_id = $1
     AND o.customer_id IS NOT NULL
     AND p.status = 'completed'
     AND p.created_at >= $2
     AND p.created_at < $3),
     previous_period AS
  (SELECT COUNT(DISTINCT o.customer_id) AS cnt
   FROM customer_order o
   JOIN payment p ON o.order_id = p.order_id
   WHERE o.store_id = $1
     AND o.customer_id IS NOT NULL
     AND p.status = 'completed'
     AND p.created_at >= ($2 - ($3 - $2))
     AND p.created_at < $2)
SELECT CASE
           WHEN previous_period.cnt = 0 THEN NULL
           ELSE ROUND(((current_period.cnt - previous_period.cnt)::numeric / previous_period.cnt) * 100, 2)
       END AS growth_percentage
FROM current_period,
     previous_period
`

type GetPurchasingCustomersGrowthPercentParams struct {
	StoreID     int64
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

func (q *Queries) GetPurchasingCustomersGrowthPercent(ctx context.Context, arg GetPurchasingCustomersGrowthPercentParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getPurchasingCustomersGrowthPercent, arg.StoreID, arg.CreatedAt, arg.CreatedAt_2)
	var growth_percentage interface{}
	err := row.Scan(&growth_percentage)
	return growth_percentage, err
}

const getRegisteredCustomers = `-- name: GetRegisteredCustomers :one

SELECT COUNT(*) AS total_customers
FROM customer c
WHERE c.store_id = $1
`

// Overview & Customers page
func (q *Queries) GetRegisteredCustomers(ctx context.Context, storeID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getRegisteredCustomers, storeID)
	var total_customers int64
	err := row.Scan(&total_customers)
	return total_customers, err
}

const getRevenueGrowthPercent = `-- name: GetRevenueGrowthPercent :one
WITH current_period AS
  (SELECT COALESCE(SUM(co.total_amount), 0) AS revenue
   FROM customer_order co
   WHERE co.store_id = $1
     AND co.status = 'completed'
     AND co.created_at >= $2
     AND co.created_at < $3),
     previous_period AS
  (SELECT COALESCE(SUM(co.total_amount), 0) AS revenue
   FROM customer_order co
   WHERE co.store_id = $1
     AND co.status = 'completed'
     AND co.created_at >= ($2 - ($3 - $2))
     AND co.created_at < $2)
SELECT CASE
           WHEN previous_period.revenue = 0 THEN NULL
           ELSE ROUND(((current_period.revenue - previous_period.revenue) / previous_period.revenue) * 100, 2)
       END AS revenue_growth_percent
FROM current_period,
     previous_period
`

type GetRevenueGrowthPercentParams struct {
	StoreID     int64
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

func (q *Queries) GetRevenueGrowthPercent(ctx context.Context, arg GetRevenueGrowthPercentParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getRevenueGrowthPercent, arg.StoreID, arg.CreatedAt, arg.CreatedAt_2)
	var revenue_growth_percent interface{}
	err := row.Scan(&revenue_growth_percent)
	return revenue_growth_percent, err
}

const getRevenueOverTime = `-- name: GetRevenueOverTime :many

SELECT DATE(co.created_at) AS order_date,
       SUM(co.total_amount) AS revenue,
       COUNT(DISTINCT co.order_id) AS total_orders
FROM customer_order co
WHERE co.store_id = $1
  AND co.created_at BETWEEN $2 AND $3
GROUP BY DATE(co.created_at)
ORDER BY order_date
`

type GetRevenueOverTimeParams struct {
	StoreID     int64
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

type GetRevenueOverTimeRow struct {
	OrderDate   time.Time
	Revenue     int64
	TotalOrders int64
}

func (q *Queries) GetRevenueOverTime(ctx context.Context, arg GetRevenueOverTimeParams) ([]GetRevenueOverTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevenueOverTime, arg.StoreID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevenueOverTimeRow
	for rows.Next() {
		var i GetRevenueOverTimeRow
		if err := rows.Scan(&i.OrderDate, &i.Revenue, &i.TotalOrders); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShippedOrders = `-- name: GetShippedOrders :one

SELECT COUNT(*) AS shipped_orders
FROM customer_order co
WHERE co.store_id = $1
  AND co.status = 'shipped'
`

func (q *Queries) GetShippedOrders(ctx context.Context, storeID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getShippedOrders, storeID)
	var shipped_orders int64
	err := row.Scan(&shipped_orders)
	return shipped_orders, err
}

const getTopSellingProducts = `-- name: GetTopSellingProducts :many

SELECT p.name AS product_name,
       SUM(oi.quantity) AS units_sold,
       SUM(oi.subtotal) AS revenue
FROM order_item oi
JOIN product_variant pv ON oi.variant_id = pv.variant_id
JOIN product p ON pv.product_id = p.product_id
JOIN customer_order co ON oi.order_id = co.order_id
WHERE co.store_id = $1
  AND co.created_at BETWEEN $2 AND $3
GROUP BY p.product_id,
         p.name
ORDER BY revenue DESC
LIMIT 5
`

type GetTopSellingProductsParams struct {
	StoreID     int64
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

type GetTopSellingProductsRow struct {
	ProductName string
	UnitsSold   int64
	Revenue     int64
}

func (q *Queries) GetTopSellingProducts(ctx context.Context, arg GetTopSellingProductsParams) ([]GetTopSellingProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopSellingProducts, arg.StoreID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSellingProductsRow
	for rows.Next() {
		var i GetTopSellingProductsRow
		if err := rows.Scan(&i.ProductName, &i.UnitsSold, &i.Revenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalOrders = `-- name: GetTotalOrders :one

SELECT COUNT(*) AS total_orders
FROM customer_order co
WHERE co.store_id = $1
`

// Orders page
func (q *Queries) GetTotalOrders(ctx context.Context, storeID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalOrders, storeID)
	var total_orders int64
	err := row.Scan(&total_orders)
	return total_orders, err
}

const getTotalProducts = `-- name: GetTotalProducts :one

SELECT COUNT(*) AS total_products
FROM product p
WHERE p.store_id = $1
  AND p.deleted_at IS NULL
`

func (q *Queries) GetTotalProducts(ctx context.Context, storeID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalProducts, storeID)
	var total_products int64
	err := row.Scan(&total_products)
	return total_products, err
}

const getTotalRevenueCurrentMonth = `-- name: GetTotalRevenueCurrentMonth :one

SELECT COALESCE(SUM(co.total_amount), 0) AS total_revenue
FROM customer_order co
WHERE co.store_id = $1
  AND co.status = 'completed'
  AND co.created_at >= $2
  AND co.created_at < $3
`

type GetTotalRevenueCurrentMonthParams struct {
	StoreID     int64
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

// In Overview and Analytics pages
func (q *Queries) GetTotalRevenueCurrentMonth(ctx context.Context, arg GetTotalRevenueCurrentMonthParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTotalRevenueCurrentMonth, arg.StoreID, arg.CreatedAt, arg.CreatedAt_2)
	var total_revenue interface{}
	err := row.Scan(&total_revenue)
	return total_revenue, err
}

const getTotalVisitors = `-- name: GetTotalVisitors :one

SELECT COUNT(DISTINCT vs.session_id) AS visitors_this_month
FROM visitor_session vs
WHERE vs.store_id = $1
  AND vs.first_seen_at >= $2
  AND vs.first_seen_at < $3
`

type GetTotalVisitorsParams struct {
	StoreID       int64
	FirstSeenAt   sql.NullTime
	FirstSeenAt_2 sql.NullTime
}

// Total visitors(Overview page) / Visitors(Analytics page)
func (q *Queries) GetTotalVisitors(ctx context.Context, arg GetTotalVisitorsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalVisitors, arg.StoreID, arg.FirstSeenAt, arg.FirstSeenAt_2)
	var visitors_this_month int64
	err := row.Scan(&visitors_this_month)
	return visitors_this_month, err
}

const listLowStockProducts = `-- name: ListLowStockProducts :many

SELECT p.name,
       p.stock_quantity,
       CASE
           WHEN p.stock_quantity = 0 THEN 'OUT_OF_STOCK'
           WHEN p.stock_quantity BETWEEN 1 AND 10 THEN 'LOW_STOCK'
       END AS stock_status,
       p.updated_at
FROM product p
WHERE p.store_id = $1
  AND p.deleted_at IS NULL
  AND p.stock_quantity <= 10
ORDER BY p.stock_quantity ASC,
         p.updated_at DESC
LIMIT $2
`

type ListLowStockProductsParams struct {
	StoreID int64
	Limit   int32
}

type ListLowStockProductsRow struct {
	Name          string
	StockQuantity int32
	StockStatus   interface{}
	UpdatedAt     sql.NullTime
}

func (q *Queries) ListLowStockProducts(ctx context.Context, arg ListLowStockProductsParams) ([]ListLowStockProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, listLowStockProducts, arg.StoreID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLowStockProductsRow
	for rows.Next() {
		var i ListLowStockProductsRow
		if err := rows.Scan(
			&i.Name,
			&i.StockQuantity,
			&i.StockStatus,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductTable = `-- name: ListProductTable :many

SELECT p.name AS product_name,
       COALESCE(SUM(oi.quantity), 0) AS units_sold,
       COALESCE(SUM(pvw.views_count), 0) AS total_views,
       CASE
           WHEN COALESCE(SUM(oi.quantity), 0) = 0 THEN NULL
           ELSE ROUND(CAST(COALESCE(SUM(pvw.views_count), 0) AS numeric) / SUM(oi.quantity), 2)
       END AS views_to_purchase_ratio,
       CASE
           WHEN COALESCE(SUM(pv.stock_quantity), 0) = 0 THEN 'out of stock'
           WHEN COALESCE(SUM(pv.stock_quantity), 0) <= 10 THEN 'low stock'
           ELSE 'in stock'
       END AS stock_status
FROM product p
LEFT JOIN product_variant pv ON pv.product_id = p.product_id
LEFT JOIN order_item oi ON oi.variant_id = pv.variant_id
LEFT JOIN customer_order o ON o.order_id = oi.order_id
AND o.status IN ('completed',
                 'shipped')
LEFT JOIN
  (SELECT pv.product_id,
          COUNT(*) AS views_count
   FROM product_view pv
   GROUP BY pv.product_id) pvw ON pvw.product_id = p.product_id
WHERE p.store_id = $1
  AND p.deleted_at IS NULL
GROUP BY p.product_id,
         p.name
ORDER BY p.name ASC
`

type ListProductTableRow struct {
	ProductName          string
	UnitsSold            interface{}
	TotalViews           interface{}
	ViewsToPurchaseRatio interface{}
	StockStatus          string
}

func (q *Queries) ListProductTable(ctx context.Context, storeID int64) ([]ListProductTableRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductTable, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductTableRow
	for rows.Next() {
		var i ListProductTableRow
		if err := rows.Scan(
			&i.ProductName,
			&i.UnitsSold,
			&i.TotalViews,
			&i.ViewsToPurchaseRatio,
			&i.StockStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
