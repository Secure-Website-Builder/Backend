// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package models

import (
	"context"
	"database/sql"
	"time"

	"github.com/Secure-Website-Builder/Backend/internal/types"
	"github.com/google/uuid"
)

const categoryHasAttribute = `-- name: CategoryHasAttribute :one
SELECT 1
FROM category_attribute
WHERE category_id = $1
  AND attribute_id = $2
`

type CategoryHasAttributeParams struct {
	CategoryID  int64
	AttributeID int64
}

func (q *Queries) CategoryHasAttribute(ctx context.Context, arg CategoryHasAttributeParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, categoryHasAttribute, arg.CategoryID, arg.AttributeID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customer (
  store_id,
  name,
  email,
  password_hash,
  phone,
  address
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING customer_id, store_id, name, email, created_at
`

type CreateCustomerParams struct {
	StoreID      int64
	Name         string
	Email        string
	PasswordHash string
	Phone        sql.NullString
	Address      types.NullableAddress
}

type CreateCustomerRow struct {
	CustomerID int64
	StoreID    int64
	Name       string
	Email      string
	CreatedAt  sql.NullTime
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (CreateCustomerRow, error) {
	row := q.db.QueryRowContext(ctx, createCustomer,
		arg.StoreID,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.Phone,
		arg.Address,
	)
	var i CreateCustomerRow
	err := row.Scan(
		&i.CustomerID,
		&i.StoreID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO product (
  store_id, category_id, name, slug, description, brand
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING product_id, store_id, category_id, name, slug, description, brand, stock_quantity, created_at, updated_at, in_stock, deleted_at, default_variant_id
`

type CreateProductParams struct {
	StoreID     int64
	CategoryID  int64
	Name        string
	Slug        sql.NullString
	Description sql.NullString
	Brand       sql.NullString
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.StoreID,
		arg.CategoryID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Brand,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.StoreID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Brand,
		&i.StockQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InStock,
		&i.DeletedAt,
		&i.DefaultVariantID,
	)
	return i, err
}

const createRefreshToken = `-- name: CreateRefreshToken :exec
INSERT INTO refresh_token (token, user_id, user_role, store_id, expires_at)
VALUES ($1, $2, $3, $4, $5)
`

type CreateRefreshTokenParams struct {
	Token     string
	UserID    int64
	UserRole  string
	StoreID   sql.NullInt64
	ExpiresAt time.Time
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error {
	_, err := q.db.ExecContext(ctx, createRefreshToken,
		arg.Token,
		arg.UserID,
		arg.UserRole,
		arg.StoreID,
		arg.ExpiresAt,
	)
	return err
}

const createStoreOwner = `-- name: CreateStoreOwner :one
INSERT INTO store_owner (
  name,
  email,
  password_hash,
  phone,
  address
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING store_owner_id, name, email, created_at
`

type CreateStoreOwnerParams struct {
	Name         string
	Email        string
	PasswordHash string
	Phone        sql.NullString
	Address      types.NullableAddress
}

type CreateStoreOwnerRow struct {
	StoreOwnerID int64
	Name         string
	Email        string
	CreatedAt    sql.NullTime
}

func (q *Queries) CreateStoreOwner(ctx context.Context, arg CreateStoreOwnerParams) (CreateStoreOwnerRow, error) {
	row := q.db.QueryRowContext(ctx, createStoreOwner,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.Phone,
		arg.Address,
	)
	var i CreateStoreOwnerRow
	err := row.Scan(
		&i.StoreOwnerID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}

const createVariant = `-- name: CreateVariant :one
INSERT INTO product_variant (
  product_id, store_id, attribute_hash,
  sku, price, stock_quantity, primary_image_url
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING variant_id, product_id, store_id, attribute_hash, sku, price, stock_quantity, primary_image_url, created_at, updated_at, deleted_at
`

type CreateVariantParams struct {
	ProductID       int64
	StoreID         int64
	AttributeHash   string
	Sku             string
	Price           string
	StockQuantity   int32
	PrimaryImageUrl string
}

func (q *Queries) CreateVariant(ctx context.Context, arg CreateVariantParams) (ProductVariant, error) {
	row := q.db.QueryRowContext(ctx, createVariant,
		arg.ProductID,
		arg.StoreID,
		arg.AttributeHash,
		arg.Sku,
		arg.Price,
		arg.StockQuantity,
		arg.PrimaryImageUrl,
	)
	var i ProductVariant
	err := row.Scan(
		&i.VariantID,
		&i.ProductID,
		&i.StoreID,
		&i.AttributeHash,
		&i.Sku,
		&i.Price,
		&i.StockQuantity,
		&i.PrimaryImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAdminByEmail = `-- name: GetAdminByEmail :one
SELECT admin_id, email, password_hash
FROM admin
WHERE email = $1
`

type GetAdminByEmailRow struct {
	AdminID      int64
	Email        string
	PasswordHash string
}

func (q *Queries) GetAdminByEmail(ctx context.Context, email string) (GetAdminByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getAdminByEmail, email)
	var i GetAdminByEmailRow
	err := row.Scan(&i.AdminID, &i.Email, &i.PasswordHash)
	return i, err
}

const getCartBySession = `-- name: GetCartBySession :one
SELECT c.cart_id, c.store_id, c.updated_at
FROM cart c
JOIN visitor_session s ON s.customer_id = c.customer_id
WHERE s.session_id = $1
  AND c.store_id = $2
LIMIT 1
`

type GetCartBySessionParams struct {
	SessionID uuid.UUID
	StoreID   int64
}

type GetCartBySessionRow struct {
	CartID    int64
	StoreID   int64
	UpdatedAt sql.NullTime
}

func (q *Queries) GetCartBySession(ctx context.Context, arg GetCartBySessionParams) (GetCartBySessionRow, error) {
	row := q.db.QueryRowContext(ctx, getCartBySession, arg.SessionID, arg.StoreID)
	var i GetCartBySessionRow
	err := row.Scan(&i.CartID, &i.StoreID, &i.UpdatedAt)
	return i, err
}

const getCartItems = `-- name: GetCartItems :many
SELECT
	ci.cart_item_id,
	ci.variant_id,
	p.product_id,
	p.name AS product_name,
	v.sku,
	v.primary_image_url,
	ci.unit_price,
	ci.quantity,
	(ci.unit_price * ci.quantity)::NUMERIC AS subtotal
FROM cart_item ci
JOIN product_variant v ON v.variant_id = ci.variant_id
JOIN product p ON p.product_id = v.product_id
WHERE ci.cart_id = $1
ORDER BY ci.created_at
`

type GetCartItemsRow struct {
	CartItemID      int64
	VariantID       int64
	ProductID       int64
	ProductName     string
	Sku             string
	PrimaryImageUrl string
	UnitPrice       string
	Quantity        int32
	Subtotal        string
}

func (q *Queries) GetCartItems(ctx context.Context, cartID int64) ([]GetCartItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCartItems, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCartItemsRow
	for rows.Next() {
		var i GetCartItemsRow
		if err := rows.Scan(
			&i.CartItemID,
			&i.VariantID,
			&i.ProductID,
			&i.ProductName,
			&i.Sku,
			&i.PrimaryImageUrl,
			&i.UnitPrice,
			&i.Quantity,
			&i.Subtotal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerByEmail = `-- name: GetCustomerByEmail :one
SELECT
  customer_id,
  store_id,
  name,
  email,
  password_hash,
  created_at
FROM customer
WHERE email = $1
  AND store_id = $2
`

type GetCustomerByEmailParams struct {
	Email   string
	StoreID int64
}

type GetCustomerByEmailRow struct {
	CustomerID   int64
	StoreID      int64
	Name         string
	Email        string
	PasswordHash string
	CreatedAt    sql.NullTime
}

func (q *Queries) GetCustomerByEmail(ctx context.Context, arg GetCustomerByEmailParams) (GetCustomerByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByEmail, arg.Email, arg.StoreID)
	var i GetCustomerByEmailRow
	err := row.Scan(
		&i.CustomerID,
		&i.StoreID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getProductBase = `-- name: GetProductBase :one
SELECT
  p.product_id,
  p.store_id,
  p.name,
  p.slug,
  p.description,
  p.brand,
  p.stock_quantity as total_stock,
  p.category_id,
  c.name as category_name,
  p.default_variant_id,
  v.price,
  p.in_stock,
  v.primary_image_url AS primary_image
FROM product p
JOIN product_variant v 
  ON v.variant_id = p.default_variant_id
JOIN category_definition c
  ON p.category_id = c.category_id
WHERE p.store_id = $1 AND p.product_id = $2 AND p.deleted_at IS NULL
`

type GetProductBaseParams struct {
	StoreID   int64
	ProductID int64
}

type GetProductBaseRow struct {
	ProductID        int64
	StoreID          int64
	Name             string
	Slug             sql.NullString
	Description      sql.NullString
	Brand            sql.NullString
	TotalStock       int32
	CategoryID       int64
	CategoryName     string
	DefaultVariantID sql.NullInt64
	Price            string
	InStock          bool
	PrimaryImage     string
}

func (q *Queries) GetProductBase(ctx context.Context, arg GetProductBaseParams) (GetProductBaseRow, error) {
	row := q.db.QueryRowContext(ctx, getProductBase, arg.StoreID, arg.ProductID)
	var i GetProductBaseRow
	err := row.Scan(
		&i.ProductID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Brand,
		&i.TotalStock,
		&i.CategoryID,
		&i.CategoryName,
		&i.DefaultVariantID,
		&i.Price,
		&i.InStock,
		&i.PrimaryImage,
	)
	return i, err
}

const getProductByIdentity = `-- name: GetProductByIdentity :one
SELECT product_id, store_id, category_id, name, slug, description, brand, stock_quantity, created_at, updated_at, in_stock, deleted_at, default_variant_id
FROM product
WHERE store_id = $1
  AND name = $2
  AND category_id = $3
  AND brand = $4
  AND deleted_at IS NULL
LIMIT 1
`

type GetProductByIdentityParams struct {
	StoreID    int64
	Name       string
	CategoryID int64
	Brand      sql.NullString
}

func (q *Queries) GetProductByIdentity(ctx context.Context, arg GetProductByIdentityParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByIdentity,
		arg.StoreID,
		arg.Name,
		arg.CategoryID,
		arg.Brand,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.StoreID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Brand,
		&i.StockQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InStock,
		&i.DeletedAt,
		&i.DefaultVariantID,
	)
	return i, err
}

const getProductByStoreAndName = `-- name: GetProductByStoreAndName :one
SELECT product_id, store_id, category_id, name, slug, description, brand, stock_quantity, created_at, updated_at, in_stock, deleted_at, default_variant_id
FROM product
WHERE store_id = $1 AND name = $2 AND deleted_at IS NULL
LIMIT 1
`

type GetProductByStoreAndNameParams struct {
	StoreID int64
	Name    string
}

func (q *Queries) GetProductByStoreAndName(ctx context.Context, arg GetProductByStoreAndNameParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByStoreAndName, arg.StoreID, arg.Name)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.StoreID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Brand,
		&i.StockQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InStock,
		&i.DeletedAt,
		&i.DefaultVariantID,
	)
	return i, err
}

const getProductForUpdate = `-- name: GetProductForUpdate :one
SELECT product_id, store_id, category_id, stock_quantity
FROM product
WHERE product_id = $1
FOR UPDATE
`

type GetProductForUpdateRow struct {
	ProductID     int64
	StoreID       int64
	CategoryID    int64
	StockQuantity int32
}

func (q *Queries) GetProductForUpdate(ctx context.Context, productID int64) (GetProductForUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, getProductForUpdate, productID)
	var i GetProductForUpdateRow
	err := row.Scan(
		&i.ProductID,
		&i.StoreID,
		&i.CategoryID,
		&i.StockQuantity,
	)
	return i, err
}

const getProductVariantAttributes = `-- name: GetProductVariantAttributes :many
SELECT
  ad.attribute_id,
  ad.name as attribute_name,
  vav.value as attribute_value
FROM variant_attribute_value vav
JOIN attribute_definition ad 
  ON vav.attribute_id = ad.attribute_id
WHERE vav.variant_id = $1
`

type GetProductVariantAttributesRow struct {
	AttributeID    int64
	AttributeName  string
	AttributeValue string
}

func (q *Queries) GetProductVariantAttributes(ctx context.Context, variantID int64) ([]GetProductVariantAttributesRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductVariantAttributes, variantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductVariantAttributesRow
	for rows.Next() {
		var i GetProductVariantAttributesRow
		if err := rows.Scan(&i.AttributeID, &i.AttributeName, &i.AttributeValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductVariants = `-- name: GetProductVariants :many
SELECT
  variant_id,
  product_id,
  sku,
  price,
  stock_quantity,
  primary_image_url
FROM product_variant
WHERE product_id = $1 AND deleted_at IS NULL
`

type GetProductVariantsRow struct {
	VariantID       int64
	ProductID       int64
	Sku             string
	Price           string
	StockQuantity   int32
	PrimaryImageUrl string
}

func (q *Queries) GetProductVariants(ctx context.Context, productID int64) ([]GetProductVariantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductVariants, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductVariantsRow
	for rows.Next() {
		var i GetProductVariantsRow
		if err := rows.Scan(
			&i.VariantID,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.StockQuantity,
			&i.PrimaryImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT refresh_token_id, token, user_id, user_role, store_id, expires_at, revoked, created_at
FROM refresh_token
WHERE token = $1 AND revoked = FALSE
`

func (q *Queries) GetRefreshToken(ctx context.Context, token string) (RefreshToken, error) {
	row := q.db.QueryRowContext(ctx, getRefreshToken, token)
	var i RefreshToken
	err := row.Scan(
		&i.RefreshTokenID,
		&i.Token,
		&i.UserID,
		&i.UserRole,
		&i.StoreID,
		&i.ExpiresAt,
		&i.Revoked,
		&i.CreatedAt,
	)
	return i, err
}

const getStoreOwnerByEmail = `-- name: GetStoreOwnerByEmail :one
SELECT
  store_owner_id,
  name,
  email,
  password_hash,
  created_at
FROM store_owner
WHERE email = $1
`

type GetStoreOwnerByEmailRow struct {
	StoreOwnerID int64
	Name         string
	Email        string
	PasswordHash string
	CreatedAt    sql.NullTime
}

func (q *Queries) GetStoreOwnerByEmail(ctx context.Context, email string) (GetStoreOwnerByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getStoreOwnerByEmail, email)
	var i GetStoreOwnerByEmailRow
	err := row.Scan(
		&i.StoreOwnerID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getTopProductsByCategory = `-- name: GetTopProductsByCategory :many
SELECT 
  p.product_id,
  p.store_id,
  p.name,
  p.slug,
  p.description,
  p.brand,
  p.category_id,
  p.default_variant_id,
  p.stock_quantity as product_total_stock,
  v.stock_quantity as item_stock,
  v.price,
  p.in_stock,
  v.primary_image_url AS primary_image
FROM product p
JOIN product_variant v 
  ON v.variant_id = p.default_variant_id
WHERE 
  p.store_id = $1 
  AND p.category_id = $2
  AND p.in_stock = TRUE
  AND p.deleted_at IS NULL
ORDER BY 
  v.stock_quantity DESC
LIMIT $3
`

type GetTopProductsByCategoryParams struct {
	StoreID    int64
	CategoryID int64
	Limit      int32
}

type GetTopProductsByCategoryRow struct {
	ProductID         int64
	StoreID           int64
	Name              string
	Slug              sql.NullString
	Description       sql.NullString
	Brand             sql.NullString
	CategoryID        int64
	DefaultVariantID  sql.NullInt64
	ProductTotalStock int32
	ItemStock         int32
	Price             string
	InStock           bool
	PrimaryImage      string
}

func (q *Queries) GetTopProductsByCategory(ctx context.Context, arg GetTopProductsByCategoryParams) ([]GetTopProductsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopProductsByCategory, arg.StoreID, arg.CategoryID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopProductsByCategoryRow
	for rows.Next() {
		var i GetTopProductsByCategoryRow
		if err := rows.Scan(
			&i.ProductID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Brand,
			&i.CategoryID,
			&i.DefaultVariantID,
			&i.ProductTotalStock,
			&i.ItemStock,
			&i.Price,
			&i.InStock,
			&i.PrimaryImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantByAttributeHash = `-- name: GetVariantByAttributeHash :one
SELECT variant_id, product_id, store_id, attribute_hash, sku, price, stock_quantity, primary_image_url, created_at, updated_at, deleted_at
FROM product_variant
WHERE product_id = $1
  AND attribute_hash = $2
  AND deleted_at IS NULL
LIMIT 1
`

type GetVariantByAttributeHashParams struct {
	ProductID     int64
	AttributeHash string
}

func (q *Queries) GetVariantByAttributeHash(ctx context.Context, arg GetVariantByAttributeHashParams) (ProductVariant, error) {
	row := q.db.QueryRowContext(ctx, getVariantByAttributeHash, arg.ProductID, arg.AttributeHash)
	var i ProductVariant
	err := row.Scan(
		&i.VariantID,
		&i.ProductID,
		&i.StoreID,
		&i.AttributeHash,
		&i.Sku,
		&i.Price,
		&i.StockQuantity,
		&i.PrimaryImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const increaseVariantStock = `-- name: IncreaseVariantStock :exec
UPDATE product_variant
SET stock_quantity = stock_quantity + $2,
    updated_at = NOW()
WHERE variant_id = $1
`

type IncreaseVariantStockParams struct {
	VariantID     int64
	StockQuantity int32
}

func (q *Queries) IncreaseVariantStock(ctx context.Context, arg IncreaseVariantStockParams) error {
	_, err := q.db.ExecContext(ctx, increaseVariantStock, arg.VariantID, arg.StockQuantity)
	return err
}

const insertVariantAttribute = `-- name: InsertVariantAttribute :exec
INSERT INTO variant_attribute_value (
  variant_id, attribute_id, value
)
VALUES ($1, $2, $3)
`

type InsertVariantAttributeParams struct {
	VariantID   int64
	AttributeID int64
	Value       string
}

func (q *Queries) InsertVariantAttribute(ctx context.Context, arg InsertVariantAttributeParams) error {
	_, err := q.db.ExecContext(ctx, insertVariantAttribute, arg.VariantID, arg.AttributeID, arg.Value)
	return err
}

const isStoreOwner = `-- name: IsStoreOwner :one
SELECT EXISTS (
    SELECT 1
    FROM store
    WHERE store_id = $1
      AND store_owner_id = $2
)
`

type IsStoreOwnerParams struct {
	StoreID      int64
	StoreOwnerID int64
}

func (q *Queries) IsStoreOwner(ctx context.Context, arg IsStoreOwnerParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isStoreOwner, arg.StoreID, arg.StoreOwnerID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listCategoriesByStore = `-- name: ListCategoriesByStore :many
SELECT c.category_id, c.name, pc.name as parent_name
FROM store_category s
JOIN category_definition c
  ON s.category_id = c.category_id
JOIN category_definition pc
  ON c.parent_id = pc.category_id
WHERE s.store_id = $1
ORDER BY c.name
`

type ListCategoriesByStoreRow struct {
	CategoryID int64
	Name       string
	ParentName string
}

func (q *Queries) ListCategoriesByStore(ctx context.Context, storeID int64) ([]ListCategoriesByStoreRow, error) {
	rows, err := q.db.QueryContext(ctx, listCategoriesByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCategoriesByStoreRow
	for rows.Next() {
		var i ListCategoriesByStoreRow
		if err := rows.Scan(&i.CategoryID, &i.Name, &i.ParentName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoryAttributes = `-- name: ListCategoryAttributes :many
SELECT a.attribute_id, a.name, ca.is_required
FROM category_attribute ca
JOIN attribute_definition a 
ON a.attribute_id = ca.attribute_id
WHERE ca.category_id = $1
`

type ListCategoryAttributesRow struct {
	AttributeID int64
	Name        string
	IsRequired  bool
}

func (q *Queries) ListCategoryAttributes(ctx context.Context, categoryID int64) ([]ListCategoryAttributesRow, error) {
	rows, err := q.db.QueryContext(ctx, listCategoryAttributes, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCategoryAttributesRow
	for rows.Next() {
		var i ListCategoryAttributesRow
		if err := rows.Scan(&i.AttributeID, &i.Name, &i.IsRequired); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveAttributeIDByName = `-- name: ResolveAttributeIDByName :one
SELECT attribute_id
FROM attribute_definition
WHERE name = $1
LIMIT 1
`

func (q *Queries) ResolveAttributeIDByName(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, resolveAttributeIDByName, name)
	var attribute_id int64
	err := row.Scan(&attribute_id)
	return attribute_id, err
}

const resolveCategoryIDByName = `-- name: ResolveCategoryIDByName :one
SELECT c.category_id
FROM category_definition c
JOIN store_category s
  ON s.category_id = c.category_id
WHERE s.store_id = $1 AND c.name = $2
LIMIT 1
`

type ResolveCategoryIDByNameParams struct {
	StoreID int64
	Name    string
}

func (q *Queries) ResolveCategoryIDByName(ctx context.Context, arg ResolveCategoryIDByNameParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, resolveCategoryIDByName, arg.StoreID, arg.Name)
	var category_id int64
	err := row.Scan(&category_id)
	return category_id, err
}

const revokeRefreshToken = `-- name: RevokeRefreshToken :exec
UPDATE refresh_token
SET revoked = TRUE
WHERE token = $1
`

func (q *Queries) RevokeRefreshToken(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, revokeRefreshToken, token)
	return err
}

const setDefaultVariant = `-- name: SetDefaultVariant :exec
UPDATE product
SET default_variant_id = $2
WHERE product_id = $1
`

type SetDefaultVariantParams struct {
	ProductID        int64
	DefaultVariantID sql.NullInt64
}

func (q *Queries) SetDefaultVariant(ctx context.Context, arg SetDefaultVariantParams) error {
	_, err := q.db.ExecContext(ctx, setDefaultVariant, arg.ProductID, arg.DefaultVariantID)
	return err
}

const updateProductStock = `-- name: UpdateProductStock :exec
UPDATE product
SET stock_quantity = stock_quantity + $2,
    in_stock = (stock_quantity + $2) > 0,
    updated_at = NOW()
WHERE product_id = $1
`

type UpdateProductStockParams struct {
	ProductID     int64
	StockQuantity int32
}

func (q *Queries) UpdateProductStock(ctx context.Context, arg UpdateProductStockParams) error {
	_, err := q.db.ExecContext(ctx, updateProductStock, arg.ProductID, arg.StockQuantity)
	return err
}
