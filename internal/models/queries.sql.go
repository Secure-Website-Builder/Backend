// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package models

import (
	"context"
	"database/sql"
	"time"

	"github.com/Secure-Website-Builder/Backend/internal/types"
	"github.com/google/uuid"
)

const attachCartToCustomer = `-- name: AttachCartToCustomer :exec
UPDATE cart
SET customer_id = $1,
    session_id  = $2,
    updated_at  = NOW()
WHERE cart_id = $3
`

type AttachCartToCustomerParams struct {
	CustomerID sql.NullInt64
	SessionID  uuid.UUID
	CartID     int64
}

func (q *Queries) AttachCartToCustomer(ctx context.Context, arg AttachCartToCustomerParams) error {
	_, err := q.db.ExecContext(ctx, attachCartToCustomer, arg.CustomerID, arg.SessionID, arg.CartID)
	return err
}

const categoryHasAttribute = `-- name: CategoryHasAttribute :one
SELECT 1
FROM category_attribute
WHERE category_id = $1
  AND attribute_id = $2
`

type CategoryHasAttributeParams struct {
	CategoryID  int64
	AttributeID int64
}

func (q *Queries) CategoryHasAttribute(ctx context.Context, arg CategoryHasAttributeParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, categoryHasAttribute, arg.CategoryID, arg.AttributeID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const clearCartItems = `-- name: ClearCartItems :exec
DELETE FROM cart_item
WHERE cart_id = $1
`

func (q *Queries) ClearCartItems(ctx context.Context, cartID int64) error {
	_, err := q.db.ExecContext(ctx, clearCartItems, cartID)
	return err
}

const createCart = `-- name: CreateCart :one
INSERT INTO cart (store_id, session_id, customer_id)
VALUES ($1, $2, $3)
RETURNING cart_id, store_id, session_id, customer_id, created_at, updated_at
`

type CreateCartParams struct {
	StoreID    int64
	SessionID  uuid.UUID
	CustomerID sql.NullInt64
}

func (q *Queries) CreateCart(ctx context.Context, arg CreateCartParams) (Cart, error) {
	row := q.db.QueryRowContext(ctx, createCart, arg.StoreID, arg.SessionID, arg.CustomerID)
	var i Cart
	err := row.Scan(
		&i.CartID,
		&i.StoreID,
		&i.SessionID,
		&i.CustomerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customer (
  store_id,
  name,
  email,
  password_hash,
  phone,
  address
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING customer_id, store_id, name, email, created_at
`

type CreateCustomerParams struct {
	StoreID      int64
	Name         string
	Email        string
	PasswordHash string
	Phone        sql.NullString
	Address      types.NullableAddress
}

type CreateCustomerRow struct {
	CustomerID int64
	StoreID    int64
	Name       string
	Email      string
	CreatedAt  time.Time
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (CreateCustomerRow, error) {
	row := q.db.QueryRowContext(ctx, createCustomer,
		arg.StoreID,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.Phone,
		arg.Address,
	)
	var i CreateCustomerRow
	err := row.Scan(
		&i.CustomerID,
		&i.StoreID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO customer_order (
  store_id,
  customer_id,
  session_id,
  total_amount
) VALUES (
  $1, $2, $3, $4
)
RETURNING order_id, store_id, customer_id, session_id, total_amount, status, created_at, updated_at
`

type CreateOrderParams struct {
	StoreID     int64
	CustomerID  sql.NullInt64
	SessionID   uuid.UUID
	TotalAmount string
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (CustomerOrder, error) {
	row := q.db.QueryRowContext(ctx, createOrder,
		arg.StoreID,
		arg.CustomerID,
		arg.SessionID,
		arg.TotalAmount,
	)
	var i CustomerOrder
	err := row.Scan(
		&i.OrderID,
		&i.StoreID,
		&i.CustomerID,
		&i.SessionID,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :exec
INSERT INTO order_item (
  order_id,
  variant_id,
  quantity,
  unit_price,
  subtotal
) VALUES (
  $1, $2, $3, $4, $5
)
`

type CreateOrderItemParams struct {
	OrderID   int64
	VariantID int64
	Quantity  int32
	UnitPrice string
	Subtotal  string
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) error {
	_, err := q.db.ExecContext(ctx, createOrderItem,
		arg.OrderID,
		arg.VariantID,
		arg.Quantity,
		arg.UnitPrice,
		arg.Subtotal,
	)
	return err
}

const createPayment = `-- name: CreatePayment :exec
INSERT INTO payment (
  order_id,
  method,
  amount,
  status,
  transaction_ref
) VALUES (
  $1, $2, $3, $4, $5
)
`

type CreatePaymentParams struct {
	OrderID        int64
	Method         string
	Amount         string
	Status         string
	TransactionRef sql.NullString
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) error {
	_, err := q.db.ExecContext(ctx, createPayment,
		arg.OrderID,
		arg.Method,
		arg.Amount,
		arg.Status,
		arg.TransactionRef,
	)
	return err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO product (
  store_id, category_id, name, slug, description, brand
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING product_id, store_id, category_id, name, slug, description, brand, stock_quantity, created_at, updated_at, in_stock, deleted_at, default_variant_id
`

type CreateProductParams struct {
	StoreID     int64
	CategoryID  int64
	Name        string
	Slug        sql.NullString
	Description sql.NullString
	Brand       sql.NullString
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.StoreID,
		arg.CategoryID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Brand,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.StoreID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Brand,
		&i.StockQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InStock,
		&i.DeletedAt,
		&i.DefaultVariantID,
	)
	return i, err
}

const createRefreshToken = `-- name: CreateRefreshToken :exec
INSERT INTO refresh_token (token, user_id, user_role, store_id, expires_at)
VALUES ($1, $2, $3, $4, $5)
`

type CreateRefreshTokenParams struct {
	Token     string
	UserID    int64
	UserRole  string
	StoreID   sql.NullInt64
	ExpiresAt time.Time
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error {
	_, err := q.db.ExecContext(ctx, createRefreshToken,
		arg.Token,
		arg.UserID,
		arg.UserRole,
		arg.StoreID,
		arg.ExpiresAt,
	)
	return err
}

const createStore = `-- name: CreateStore :one
INSERT INTO store (
    store_owner_id,
    name,
    domain,
    currency,
    timezone
) VALUES ($1, $2, $3, $4, $5)
RETURNING store_id, store_owner_id, name, domain, download_status, currency, timezone, created_at, updated_at
`

type CreateStoreParams struct {
	StoreOwnerID int64
	Name         string
	Domain       sql.NullString
	Currency     sql.NullString
	Timezone     sql.NullString
}

func (q *Queries) CreateStore(ctx context.Context, arg CreateStoreParams) (Store, error) {
	row := q.db.QueryRowContext(ctx, createStore,
		arg.StoreOwnerID,
		arg.Name,
		arg.Domain,
		arg.Currency,
		arg.Timezone,
	)
	var i Store
	err := row.Scan(
		&i.StoreID,
		&i.StoreOwnerID,
		&i.Name,
		&i.Domain,
		&i.DownloadStatus,
		&i.Currency,
		&i.Timezone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createStoreOwner = `-- name: CreateStoreOwner :one
INSERT INTO store_owner (
  name,
  email,
  password_hash,
  phone,
  address
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING store_owner_id, name, email, created_at
`

type CreateStoreOwnerParams struct {
	Name         string
	Email        string
	PasswordHash string
	Phone        sql.NullString
	Address      types.NullableAddress
}

type CreateStoreOwnerRow struct {
	StoreOwnerID int64
	Name         string
	Email        string
	CreatedAt    time.Time
}

func (q *Queries) CreateStoreOwner(ctx context.Context, arg CreateStoreOwnerParams) (CreateStoreOwnerRow, error) {
	row := q.db.QueryRowContext(ctx, createStoreOwner,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.Phone,
		arg.Address,
	)
	var i CreateStoreOwnerRow
	err := row.Scan(
		&i.StoreOwnerID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}

const createVariant = `-- name: CreateVariant :one
INSERT INTO product_variant (
  product_id, store_id, attribute_hash,
  sku, price, stock_quantity
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING variant_id, product_id, store_id, attribute_hash, sku, price, stock_quantity, primary_image_url, created_at, updated_at, deleted_at
`

type CreateVariantParams struct {
	ProductID     int64
	StoreID       int64
	AttributeHash string
	Sku           string
	Price         string
	StockQuantity int32
}

func (q *Queries) CreateVariant(ctx context.Context, arg CreateVariantParams) (ProductVariant, error) {
	row := q.db.QueryRowContext(ctx, createVariant,
		arg.ProductID,
		arg.StoreID,
		arg.AttributeHash,
		arg.Sku,
		arg.Price,
		arg.StockQuantity,
	)
	var i ProductVariant
	err := row.Scan(
		&i.VariantID,
		&i.ProductID,
		&i.StoreID,
		&i.AttributeHash,
		&i.Sku,
		&i.Price,
		&i.StockQuantity,
		&i.PrimaryImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const decreaseVariantStock = `-- name: DecreaseVariantStock :exec
UPDATE product_variant
SET stock_quantity = stock_quantity - $2,
    updated_at = NOW()
WHERE variant_id = $1
`

type DecreaseVariantStockParams struct {
	VariantID    int64
	CartQuantity int32
}

func (q *Queries) DecreaseVariantStock(ctx context.Context, arg DecreaseVariantStockParams) error {
	_, err := q.db.ExecContext(ctx, decreaseVariantStock, arg.VariantID, arg.CartQuantity)
	return err
}

const deleteCart = `-- name: DeleteCart :exec
DELETE FROM cart
WHERE cart_id = $1
`

func (q *Queries) DeleteCart(ctx context.Context, cartID int64) error {
	_, err := q.db.ExecContext(ctx, deleteCart, cartID)
	return err
}

const deleteStore = `-- name: DeleteStore :exec
DELETE FROM store
WHERE store_id = $1
`

func (q *Queries) DeleteStore(ctx context.Context, storeID int64) error {
	_, err := q.db.ExecContext(ctx, deleteStore, storeID)
	return err
}

const getAdminByEmail = `-- name: GetAdminByEmail :one
SELECT admin_id, email, password_hash
FROM admin
WHERE email = $1
`

type GetAdminByEmailRow struct {
	AdminID      int64
	Email        string
	PasswordHash string
}

func (q *Queries) GetAdminByEmail(ctx context.Context, email string) (GetAdminByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getAdminByEmail, email)
	var i GetAdminByEmailRow
	err := row.Scan(&i.AdminID, &i.Email, &i.PasswordHash)
	return i, err
}

const getCartByCustomerForUpdate = `-- name: GetCartByCustomerForUpdate :one
SELECT cart_id, store_id, session_id, customer_id, created_at, updated_at
FROM cart
WHERE store_id = $1 AND customer_id = $2
FOR UPDATE
`

type GetCartByCustomerForUpdateParams struct {
	StoreID    int64
	CustomerID sql.NullInt64
}

func (q *Queries) GetCartByCustomerForUpdate(ctx context.Context, arg GetCartByCustomerForUpdateParams) (Cart, error) {
	row := q.db.QueryRowContext(ctx, getCartByCustomerForUpdate, arg.StoreID, arg.CustomerID)
	var i Cart
	err := row.Scan(
		&i.CartID,
		&i.StoreID,
		&i.SessionID,
		&i.CustomerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartBySession = `-- name: GetCartBySession :one
SELECT
  c.cart_id,
  c.store_id,
  c.updated_at
FROM cart c
WHERE c.session_id = $1
  AND c.store_id = $2
LIMIT 1
`

type GetCartBySessionParams struct {
	SessionID uuid.UUID
	StoreID   int64
}

type GetCartBySessionRow struct {
	CartID    int64
	StoreID   int64
	UpdatedAt sql.NullTime
}

func (q *Queries) GetCartBySession(ctx context.Context, arg GetCartBySessionParams) (GetCartBySessionRow, error) {
	row := q.db.QueryRowContext(ctx, getCartBySession, arg.SessionID, arg.StoreID)
	var i GetCartBySessionRow
	err := row.Scan(&i.CartID, &i.StoreID, &i.UpdatedAt)
	return i, err
}

const getCartBySessionForUpdate = `-- name: GetCartBySessionForUpdate :one
SELECT cart_id, store_id, session_id, customer_id, created_at, updated_at
FROM cart
WHERE store_id = $1 AND session_id = $2
FOR UPDATE
`

type GetCartBySessionForUpdateParams struct {
	StoreID   int64
	SessionID uuid.UUID
}

func (q *Queries) GetCartBySessionForUpdate(ctx context.Context, arg GetCartBySessionForUpdateParams) (Cart, error) {
	row := q.db.QueryRowContext(ctx, getCartBySessionForUpdate, arg.StoreID, arg.SessionID)
	var i Cart
	err := row.Scan(
		&i.CartID,
		&i.StoreID,
		&i.SessionID,
		&i.CustomerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartForSession = `-- name: GetCartForSession :one
SELECT cart_id, store_id, session_id, customer_id, created_at, updated_at
FROM cart
WHERE store_id = $1 AND session_id = $2
FOR UPDATE
`

type GetCartForSessionParams struct {
	StoreID   int64
	SessionID uuid.UUID
}

func (q *Queries) GetCartForSession(ctx context.Context, arg GetCartForSessionParams) (Cart, error) {
	row := q.db.QueryRowContext(ctx, getCartForSession, arg.StoreID, arg.SessionID)
	var i Cart
	err := row.Scan(
		&i.CartID,
		&i.StoreID,
		&i.SessionID,
		&i.CustomerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartItems = `-- name: GetCartItems :many
SELECT
	ci.cart_item_id,
	ci.variant_id,
	p.product_id,
	p.name AS product_name,
	v.sku,
	v.primary_image_url,
	ci.unit_price,
	ci.quantity,
	(ci.unit_price * ci.quantity)::NUMERIC AS subtotal
FROM cart_item ci
JOIN product_variant v ON v.variant_id = ci.variant_id
JOIN product p ON p.product_id = v.product_id
WHERE ci.cart_id = $1
ORDER BY ci.created_at
`

type GetCartItemsRow struct {
	CartItemID      int64
	VariantID       int64
	ProductID       int64
	ProductName     string
	Sku             string
	PrimaryImageUrl sql.NullString
	UnitPrice       string
	Quantity        int32
	Subtotal        string
}

func (q *Queries) GetCartItems(ctx context.Context, cartID int64) ([]GetCartItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCartItems, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCartItemsRow
	for rows.Next() {
		var i GetCartItemsRow
		if err := rows.Scan(
			&i.CartItemID,
			&i.VariantID,
			&i.ProductID,
			&i.ProductName,
			&i.Sku,
			&i.PrimaryImageUrl,
			&i.UnitPrice,
			&i.Quantity,
			&i.Subtotal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCartItemsForUpdate = `-- name: GetCartItemsForUpdate :many
SELECT
  ci.cart_item_id,
  ci.variant_id,
  ci.quantity AS cart_quantity,
  ci.unit_price,
  v.stock_quantity AS available_stock,
  (v.unit_price * ci.quantity)::NUMERIC AS subtotal
FROM cart_item ci
JOIN product_variant v ON v.variant_id = ci.variant_id
WHERE ci.cart_id = $1
FOR UPDATE
`

type GetCartItemsForUpdateRow struct {
	CartItemID     int64
	VariantID      int64
	CartQuantity   int32
	UnitPrice      string
	AvailableStock int32
	Subtotal       string
}

func (q *Queries) GetCartItemsForUpdate(ctx context.Context, cartID int64) ([]GetCartItemsForUpdateRow, error) {
	rows, err := q.db.QueryContext(ctx, getCartItemsForUpdate, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCartItemsForUpdateRow
	for rows.Next() {
		var i GetCartItemsForUpdateRow
		if err := rows.Scan(
			&i.CartItemID,
			&i.VariantID,
			&i.CartQuantity,
			&i.UnitPrice,
			&i.AvailableStock,
			&i.Subtotal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCartTotal = `-- name: GetCartTotal :one
SELECT
  COALESCE(SUM(ci.unit_price * ci.quantity), 0)::NUMERIC AS total
FROM cart_item ci
WHERE ci.cart_id = $1
`

func (q *Queries) GetCartTotal(ctx context.Context, cartID int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getCartTotal, cartID)
	var total string
	err := row.Scan(&total)
	return total, err
}

const getCustomerByEmail = `-- name: GetCustomerByEmail :one
SELECT
  customer_id,
  store_id,
  name,
  email,
  password_hash,
  created_at
FROM customer
WHERE email = $1
  AND store_id = $2
`

type GetCustomerByEmailParams struct {
	Email   string
	StoreID int64
}

type GetCustomerByEmailRow struct {
	CustomerID   int64
	StoreID      int64
	Name         string
	Email        string
	PasswordHash string
	CreatedAt    time.Time
}

func (q *Queries) GetCustomerByEmail(ctx context.Context, arg GetCustomerByEmailParams) (GetCustomerByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByEmail, arg.Email, arg.StoreID)
	var i GetCustomerByEmailRow
	err := row.Scan(
		&i.CustomerID,
		&i.StoreID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getProductBase = `-- name: GetProductBase :one
SELECT
  p.product_id,
  p.store_id,
  p.name,
  p.slug,
  p.description,
  p.brand,
  p.stock_quantity as total_stock,
  p.category_id,
  c.name as category_name,
  p.default_variant_id,
  v.price,
  p.in_stock,
  v.primary_image_url AS primary_image
FROM product p
JOIN product_variant v 
  ON v.variant_id = p.default_variant_id
JOIN category_definition c
  ON p.category_id = c.category_id
WHERE p.store_id = $1 AND p.product_id = $2 AND p.deleted_at IS NULL
`

type GetProductBaseParams struct {
	StoreID   int64
	ProductID int64
}

type GetProductBaseRow struct {
	ProductID        int64
	StoreID          int64
	Name             string
	Slug             sql.NullString
	Description      sql.NullString
	Brand            sql.NullString
	TotalStock       int32
	CategoryID       int64
	CategoryName     string
	DefaultVariantID sql.NullInt64
	Price            string
	InStock          bool
	PrimaryImage     sql.NullString
}

func (q *Queries) GetProductBase(ctx context.Context, arg GetProductBaseParams) (GetProductBaseRow, error) {
	row := q.db.QueryRowContext(ctx, getProductBase, arg.StoreID, arg.ProductID)
	var i GetProductBaseRow
	err := row.Scan(
		&i.ProductID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Brand,
		&i.TotalStock,
		&i.CategoryID,
		&i.CategoryName,
		&i.DefaultVariantID,
		&i.Price,
		&i.InStock,
		&i.PrimaryImage,
	)
	return i, err
}

const getProductByIdentity = `-- name: GetProductByIdentity :one
SELECT product_id, store_id, category_id, name, slug, description, brand, stock_quantity, created_at, updated_at, in_stock, deleted_at, default_variant_id
FROM product
WHERE store_id = $1
  AND name = $2
  AND category_id = $3
  AND brand = $4
  AND deleted_at IS NULL
LIMIT 1
`

type GetProductByIdentityParams struct {
	StoreID    int64
	Name       string
	CategoryID int64
	Brand      sql.NullString
}

func (q *Queries) GetProductByIdentity(ctx context.Context, arg GetProductByIdentityParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByIdentity,
		arg.StoreID,
		arg.Name,
		arg.CategoryID,
		arg.Brand,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.StoreID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Brand,
		&i.StockQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InStock,
		&i.DeletedAt,
		&i.DefaultVariantID,
	)
	return i, err
}

const getProductByStoreAndName = `-- name: GetProductByStoreAndName :one
SELECT product_id, store_id, category_id, name, slug, description, brand, stock_quantity, created_at, updated_at, in_stock, deleted_at, default_variant_id
FROM product
WHERE store_id = $1 AND name = $2 AND deleted_at IS NULL
LIMIT 1
`

type GetProductByStoreAndNameParams struct {
	StoreID int64
	Name    string
}

func (q *Queries) GetProductByStoreAndName(ctx context.Context, arg GetProductByStoreAndNameParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByStoreAndName, arg.StoreID, arg.Name)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.StoreID,
		&i.CategoryID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Brand,
		&i.StockQuantity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InStock,
		&i.DeletedAt,
		&i.DefaultVariantID,
	)
	return i, err
}

const getProductForUpdate = `-- name: GetProductForUpdate :one
SELECT product_id, store_id, category_id, stock_quantity
FROM product
WHERE product_id = $1
FOR UPDATE
`

type GetProductForUpdateRow struct {
	ProductID     int64
	StoreID       int64
	CategoryID    int64
	StockQuantity int32
}

func (q *Queries) GetProductForUpdate(ctx context.Context, productID int64) (GetProductForUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, getProductForUpdate, productID)
	var i GetProductForUpdateRow
	err := row.Scan(
		&i.ProductID,
		&i.StoreID,
		&i.CategoryID,
		&i.StockQuantity,
	)
	return i, err
}

const getProductVariantAttributes = `-- name: GetProductVariantAttributes :many
SELECT
  ad.attribute_id,
  ad.name as attribute_name,
  vav.value as attribute_value
FROM variant_attribute_value vav
JOIN attribute_definition ad 
  ON vav.attribute_id = ad.attribute_id
WHERE vav.variant_id = $1
`

type GetProductVariantAttributesRow struct {
	AttributeID    int64
	AttributeName  string
	AttributeValue string
}

func (q *Queries) GetProductVariantAttributes(ctx context.Context, variantID int64) ([]GetProductVariantAttributesRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductVariantAttributes, variantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductVariantAttributesRow
	for rows.Next() {
		var i GetProductVariantAttributesRow
		if err := rows.Scan(&i.AttributeID, &i.AttributeName, &i.AttributeValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductVariants = `-- name: GetProductVariants :many
SELECT
  variant_id,
  product_id,
  sku,
  price,
  stock_quantity,
  primary_image_url
FROM product_variant
WHERE product_id = $1 AND deleted_at IS NULL
`

type GetProductVariantsRow struct {
	VariantID       int64
	ProductID       int64
	Sku             string
	Price           string
	StockQuantity   int32
	PrimaryImageUrl sql.NullString
}

func (q *Queries) GetProductVariants(ctx context.Context, productID int64) ([]GetProductVariantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductVariants, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductVariantsRow
	for rows.Next() {
		var i GetProductVariantsRow
		if err := rows.Scan(
			&i.VariantID,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.StockQuantity,
			&i.PrimaryImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT refresh_token_id, token, user_id, user_role, store_id, expires_at, revoked, created_at
FROM refresh_token
WHERE token = $1 AND revoked = FALSE
`

func (q *Queries) GetRefreshToken(ctx context.Context, token string) (RefreshToken, error) {
	row := q.db.QueryRowContext(ctx, getRefreshToken, token)
	var i RefreshToken
	err := row.Scan(
		&i.RefreshTokenID,
		&i.Token,
		&i.UserID,
		&i.UserRole,
		&i.StoreID,
		&i.ExpiresAt,
		&i.Revoked,
		&i.CreatedAt,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT session_id, customer_id
FROM visitor_session
WHERE session_id = $1 AND store_id = $2
`

type GetSessionParams struct {
	SessionID uuid.UUID
	StoreID   int64
}

type GetSessionRow struct {
	SessionID  uuid.UUID
	CustomerID sql.NullInt64
}

func (q *Queries) GetSession(ctx context.Context, arg GetSessionParams) (GetSessionRow, error) {
	row := q.db.QueryRowContext(ctx, getSession, arg.SessionID, arg.StoreID)
	var i GetSessionRow
	err := row.Scan(&i.SessionID, &i.CustomerID)
	return i, err
}

const getStore = `-- name: GetStore :one
SELECT store_id, store_owner_id, name, domain, download_status, currency, timezone, created_at, updated_at
FROM store
WHERE store_id = $1
`

func (q *Queries) GetStore(ctx context.Context, storeID int64) (Store, error) {
	row := q.db.QueryRowContext(ctx, getStore, storeID)
	var i Store
	err := row.Scan(
		&i.StoreID,
		&i.StoreOwnerID,
		&i.Name,
		&i.Domain,
		&i.DownloadStatus,
		&i.Currency,
		&i.Timezone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStoreByOwnerID = `-- name: GetStoreByOwnerID :one
SELECT store_id, store_owner_id, name, domain, download_status, currency, timezone, created_at, updated_at
FROM store
WHERE store_owner_id = $1
`

func (q *Queries) GetStoreByOwnerID(ctx context.Context, storeOwnerID int64) (Store, error) {
	row := q.db.QueryRowContext(ctx, getStoreByOwnerID, storeOwnerID)
	var i Store
	err := row.Scan(
		&i.StoreID,
		&i.StoreOwnerID,
		&i.Name,
		&i.Domain,
		&i.DownloadStatus,
		&i.Currency,
		&i.Timezone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStoreOwnerByEmail = `-- name: GetStoreOwnerByEmail :one
SELECT
  store_owner_id,
  name,
  email,
  password_hash,
  created_at
FROM store_owner
WHERE email = $1
`

type GetStoreOwnerByEmailRow struct {
	StoreOwnerID int64
	Name         string
	Email        string
	PasswordHash string
	CreatedAt    time.Time
}

func (q *Queries) GetStoreOwnerByEmail(ctx context.Context, email string) (GetStoreOwnerByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getStoreOwnerByEmail, email)
	var i GetStoreOwnerByEmailRow
	err := row.Scan(
		&i.StoreOwnerID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getTopProductsByCategory = `-- name: GetTopProductsByCategory :many
SELECT 
  p.product_id,
  p.store_id,
  p.name,
  p.slug,
  p.description,
  p.brand,
  p.category_id,
  p.default_variant_id,
  p.stock_quantity as product_total_stock,
  v.stock_quantity as item_stock,
  v.price,
  p.in_stock,
  v.primary_image_url AS primary_image
FROM product p
JOIN product_variant v 
  ON v.variant_id = p.default_variant_id
WHERE 
  p.store_id = $1 
  AND p.category_id = $2
  AND p.in_stock = TRUE
  AND p.deleted_at IS NULL
ORDER BY 
  v.stock_quantity DESC
LIMIT $3
`

type GetTopProductsByCategoryParams struct {
	StoreID    int64
	CategoryID int64
	Limit      int32
}

type GetTopProductsByCategoryRow struct {
	ProductID         int64
	StoreID           int64
	Name              string
	Slug              sql.NullString
	Description       sql.NullString
	Brand             sql.NullString
	CategoryID        int64
	DefaultVariantID  sql.NullInt64
	ProductTotalStock int32
	ItemStock         int32
	Price             string
	InStock           bool
	PrimaryImage      sql.NullString
}

func (q *Queries) GetTopProductsByCategory(ctx context.Context, arg GetTopProductsByCategoryParams) ([]GetTopProductsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopProductsByCategory, arg.StoreID, arg.CategoryID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopProductsByCategoryRow
	for rows.Next() {
		var i GetTopProductsByCategoryRow
		if err := rows.Scan(
			&i.ProductID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Brand,
			&i.CategoryID,
			&i.DefaultVariantID,
			&i.ProductTotalStock,
			&i.ItemStock,
			&i.Price,
			&i.InStock,
			&i.PrimaryImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariant = `-- name: GetVariant :one
SELECT variant_id, product_id, store_id, attribute_hash, sku, price, stock_quantity, primary_image_url, created_at, updated_at, deleted_at
FROM product_variant
WHERE variant_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetVariant(ctx context.Context, variantID int64) (ProductVariant, error) {
	row := q.db.QueryRowContext(ctx, getVariant, variantID)
	var i ProductVariant
	err := row.Scan(
		&i.VariantID,
		&i.ProductID,
		&i.StoreID,
		&i.AttributeHash,
		&i.Sku,
		&i.Price,
		&i.StockQuantity,
		&i.PrimaryImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getVariantByAttributeHash = `-- name: GetVariantByAttributeHash :one
SELECT variant_id, product_id, store_id, attribute_hash, sku, price, stock_quantity, primary_image_url, created_at, updated_at, deleted_at
FROM product_variant
WHERE product_id = $1
  AND attribute_hash = $2
  AND deleted_at IS NULL
LIMIT 1
`

type GetVariantByAttributeHashParams struct {
	ProductID     int64
	AttributeHash string
}

func (q *Queries) GetVariantByAttributeHash(ctx context.Context, arg GetVariantByAttributeHashParams) (ProductVariant, error) {
	row := q.db.QueryRowContext(ctx, getVariantByAttributeHash, arg.ProductID, arg.AttributeHash)
	var i ProductVariant
	err := row.Scan(
		&i.VariantID,
		&i.ProductID,
		&i.StoreID,
		&i.AttributeHash,
		&i.Sku,
		&i.Price,
		&i.StockQuantity,
		&i.PrimaryImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getVariantForCart = `-- name: GetVariantForCart :one
SELECT
  variant_id,
  price,
  stock_quantity
FROM product_variant
WHERE variant_id = $1
  AND store_id = $2
  AND deleted_at IS NULL
FOR UPDATE
`

type GetVariantForCartParams struct {
	VariantID int64
	StoreID   int64
}

type GetVariantForCartRow struct {
	VariantID     int64
	Price         string
	StockQuantity int32
}

func (q *Queries) GetVariantForCart(ctx context.Context, arg GetVariantForCartParams) (GetVariantForCartRow, error) {
	row := q.db.QueryRowContext(ctx, getVariantForCart, arg.VariantID, arg.StoreID)
	var i GetVariantForCartRow
	err := row.Scan(&i.VariantID, &i.Price, &i.StockQuantity)
	return i, err
}

const getVariantForUpdate = `-- name: GetVariantForUpdate :one
SELECT variant_id, product_id, store_id, attribute_hash, sku, price, stock_quantity, primary_image_url, created_at, updated_at, deleted_at
FROM product_variant
WHERE variant_id = $1
  AND deleted_at IS NULL
FOR UPDATE
`

func (q *Queries) GetVariantForUpdate(ctx context.Context, variantID int64) (ProductVariant, error) {
	row := q.db.QueryRowContext(ctx, getVariantForUpdate, variantID)
	var i ProductVariant
	err := row.Scan(
		&i.VariantID,
		&i.ProductID,
		&i.StoreID,
		&i.AttributeHash,
		&i.Sku,
		&i.Price,
		&i.StockQuantity,
		&i.PrimaryImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const increaseVariantStock = `-- name: IncreaseVariantStock :exec
UPDATE product_variant
SET stock_quantity = stock_quantity + $2,
    updated_at = NOW()
WHERE variant_id = $1
`

type IncreaseVariantStockParams struct {
	VariantID     int64
	StockQuantity int32
}

func (q *Queries) IncreaseVariantStock(ctx context.Context, arg IncreaseVariantStockParams) error {
	_, err := q.db.ExecContext(ctx, increaseVariantStock, arg.VariantID, arg.StockQuantity)
	return err
}

const insertVariantAttribute = `-- name: InsertVariantAttribute :exec
INSERT INTO variant_attribute_value (
  variant_id, attribute_id, value
)
VALUES ($1, $2, $3)
`

type InsertVariantAttributeParams struct {
	VariantID   int64
	AttributeID int64
	Value       string
}

func (q *Queries) InsertVariantAttribute(ctx context.Context, arg InsertVariantAttributeParams) error {
	_, err := q.db.ExecContext(ctx, insertVariantAttribute, arg.VariantID, arg.AttributeID, arg.Value)
	return err
}

const insertVariantImage = `-- name: InsertVariantImage :one
INSERT INTO product_variant_image (product_variant_id, image_url)
VALUES ($1, $2)
RETURNING image_id, product_variant_id, image_url, created_at
`

type InsertVariantImageParams struct {
	ProductVariantID int64
	ImageUrl         string
}

func (q *Queries) InsertVariantImage(ctx context.Context, arg InsertVariantImageParams) (ProductVariantImage, error) {
	row := q.db.QueryRowContext(ctx, insertVariantImage, arg.ProductVariantID, arg.ImageUrl)
	var i ProductVariantImage
	err := row.Scan(
		&i.ImageID,
		&i.ProductVariantID,
		&i.ImageUrl,
		&i.CreatedAt,
	)
	return i, err
}

const isStoreOwner = `-- name: IsStoreOwner :one
SELECT EXISTS (
    SELECT 1
    FROM store
    WHERE store_id = $1
      AND store_owner_id = $2
)
`

type IsStoreOwnerParams struct {
	StoreID      int64
	StoreOwnerID int64
}

func (q *Queries) IsStoreOwner(ctx context.Context, arg IsStoreOwnerParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isStoreOwner, arg.StoreID, arg.StoreOwnerID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listCategoriesByStore = `-- name: ListCategoriesByStore :many
SELECT c.category_id, c.name, pc.name as parent_name
FROM store_category s
JOIN category_definition c
  ON s.category_id = c.category_id
JOIN category_definition pc
  ON c.parent_id = pc.category_id
WHERE s.store_id = $1
ORDER BY c.name
`

type ListCategoriesByStoreRow struct {
	CategoryID int64
	Name       string
	ParentName string
}

func (q *Queries) ListCategoriesByStore(ctx context.Context, storeID int64) ([]ListCategoriesByStoreRow, error) {
	rows, err := q.db.QueryContext(ctx, listCategoriesByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCategoriesByStoreRow
	for rows.Next() {
		var i ListCategoriesByStoreRow
		if err := rows.Scan(&i.CategoryID, &i.Name, &i.ParentName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoryAttributes = `-- name: ListCategoryAttributes :many
SELECT a.attribute_id, a.name, ca.is_required
FROM category_attribute ca
JOIN attribute_definition a 
ON a.attribute_id = ca.attribute_id
WHERE ca.category_id = $1
`

type ListCategoryAttributesRow struct {
	AttributeID int64
	Name        string
	IsRequired  bool
}

func (q *Queries) ListCategoryAttributes(ctx context.Context, categoryID int64) ([]ListCategoryAttributesRow, error) {
	rows, err := q.db.QueryContext(ctx, listCategoryAttributes, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCategoryAttributesRow
	for rows.Next() {
		var i ListCategoryAttributesRow
		if err := rows.Scan(&i.AttributeID, &i.Name, &i.IsRequired); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergeCartItems = `-- name: MergeCartItems :exec
WITH updated AS (
  UPDATE cart_item dst
  SET quantity = dst.quantity + src.quantity,
      updated_at = NOW()
  FROM cart_item src
  WHERE src.cart_id = $2
    AND dst.cart_id = $1
    AND src.variant_id = dst.variant_id
  RETURNING src.cart_item_id
)
INSERT INTO cart_item (
  cart_id,
  variant_id,
  quantity,
  unit_price,
  created_at,
  updated_at
)
SELECT
  $1,
  src.variant_id,
  src.quantity,
  src.unit_price,
  NOW(),
  NOW()
FROM cart_item src
WHERE src.cart_id = $2
  AND NOT EXISTS (
    SELECT 1
    FROM updated u
    WHERE u.cart_item_id = src.cart_item_id
  )
`

type MergeCartItemsParams struct {
	ToCartID   int64
	FromCartID int64
}

func (q *Queries) MergeCartItems(ctx context.Context, arg MergeCartItemsParams) error {
	_, err := q.db.ExecContext(ctx, mergeCartItems, arg.ToCartID, arg.FromCartID)
	return err
}

const resolveAttributeIDByName = `-- name: ResolveAttributeIDByName :one
SELECT attribute_id
FROM attribute_definition
WHERE name = $1
LIMIT 1
`

func (q *Queries) ResolveAttributeIDByName(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, resolveAttributeIDByName, name)
	var attribute_id int64
	err := row.Scan(&attribute_id)
	return attribute_id, err
}

const resolveCategoryIDByName = `-- name: ResolveCategoryIDByName :one
SELECT c.category_id
FROM category_definition c
JOIN store_category s
  ON s.category_id = c.category_id
WHERE s.store_id = $1 AND c.name = $2
LIMIT 1
`

type ResolveCategoryIDByNameParams struct {
	StoreID int64
	Name    string
}

func (q *Queries) ResolveCategoryIDByName(ctx context.Context, arg ResolveCategoryIDByNameParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, resolveCategoryIDByName, arg.StoreID, arg.Name)
	var category_id int64
	err := row.Scan(&category_id)
	return category_id, err
}

const revokeRefreshToken = `-- name: RevokeRefreshToken :exec
UPDATE refresh_token
SET revoked = TRUE
WHERE token = $1
`

func (q *Queries) RevokeRefreshToken(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, revokeRefreshToken, token)
	return err
}

const setDefaultVariant = `-- name: SetDefaultVariant :exec
UPDATE product
SET default_variant_id = $2
WHERE product_id = $1
`

type SetDefaultVariantParams struct {
	ProductID        int64
	DefaultVariantID sql.NullInt64
}

func (q *Queries) SetDefaultVariant(ctx context.Context, arg SetDefaultVariantParams) error {
	_, err := q.db.ExecContext(ctx, setDefaultVariant, arg.ProductID, arg.DefaultVariantID)
	return err
}

const setPrimaryVariantImage = `-- name: SetPrimaryVariantImage :exec
UPDATE product_variant
SET primary_image_url = $2
WHERE variant_id = $1
`

type SetPrimaryVariantImageParams struct {
	VariantID       int64
	PrimaryImageUrl sql.NullString
}

func (q *Queries) SetPrimaryVariantImage(ctx context.Context, arg SetPrimaryVariantImageParams) error {
	_, err := q.db.ExecContext(ctx, setPrimaryVariantImage, arg.VariantID, arg.PrimaryImageUrl)
	return err
}

const touchCart = `-- name: TouchCart :exec
UPDATE cart SET updated_at = NOW() WHERE cart_id = $1
`

func (q *Queries) TouchCart(ctx context.Context, cartID int64) error {
	_, err := q.db.ExecContext(ctx, touchCart, cartID)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE customer_order
SET status = $2,
    updated_at = NOW()
WHERE order_id = $1
`

type UpdateOrderStatusParams struct {
	OrderID int64
	Status  sql.NullString
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateOrderStatus, arg.OrderID, arg.Status)
	return err
}

const updateProductStock = `-- name: UpdateProductStock :exec
UPDATE product
SET stock_quantity = stock_quantity + $2,
    in_stock = (stock_quantity + $2) > 0,
    updated_at = NOW()
WHERE product_id = $1
`

type UpdateProductStockParams struct {
	ProductID     int64
	StockQuantity int32
}

func (q *Queries) UpdateProductStock(ctx context.Context, arg UpdateProductStockParams) error {
	_, err := q.db.ExecContext(ctx, updateProductStock, arg.ProductID, arg.StockQuantity)
	return err
}

const updateStoreDownloadStatus = `-- name: UpdateStoreDownloadStatus :exec
UPDATE store
SET download_status = $2,
    updated_at = NOW()
WHERE store_id = $1
`

type UpdateStoreDownloadStatusParams struct {
	StoreID        int64
	DownloadStatus string
}

func (q *Queries) UpdateStoreDownloadStatus(ctx context.Context, arg UpdateStoreDownloadStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateStoreDownloadStatus, arg.StoreID, arg.DownloadStatus)
	return err
}

const upsertCartItem = `-- name: UpsertCartItem :exec
INSERT INTO cart_item (cart_id, variant_id, quantity, unit_price)
VALUES ($1, $2, $3, $4)
ON CONFLICT (cart_id, variant_id)
DO UPDATE SET
  quantity = cart_item.quantity + EXCLUDED.quantity
`

type UpsertCartItemParams struct {
	CartID    int64
	VariantID int64
	Quantity  int32
	UnitPrice string
}

func (q *Queries) UpsertCartItem(ctx context.Context, arg UpsertCartItemParams) error {
	_, err := q.db.ExecContext(ctx, upsertCartItem,
		arg.CartID,
		arg.VariantID,
		arg.Quantity,
		arg.UnitPrice,
	)
	return err
}
