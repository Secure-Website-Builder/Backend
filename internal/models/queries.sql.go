// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package models

import (
	"context"
	"database/sql"

	"github.com/Secure-Website-Builder/Backend/internal/types"
	"github.com/google/uuid"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customer (
  store_id,
  name,
  email,
  password_hash,
  phone,
  address
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING customer_id, store_id, name, email, created_at
`

type CreateCustomerParams struct {
	StoreID      int64
	Name         string
	Email        string
	PasswordHash string
	Phone        sql.NullString
	Address      types.NullableAddress
}

type CreateCustomerRow struct {
	CustomerID int64
	StoreID    int64
	Name       string
	Email      string
	CreatedAt  sql.NullTime
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (CreateCustomerRow, error) {
	row := q.db.QueryRowContext(ctx, createCustomer,
		arg.StoreID,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.Phone,
		arg.Address,
	)
	var i CreateCustomerRow
	err := row.Scan(
		&i.CustomerID,
		&i.StoreID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}

const createStoreOwner = `-- name: CreateStoreOwner :one
INSERT INTO store_owner (
  name,
  email,
  password_hash,
  phone,
  address
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING store_owner_id, name, email, created_at
`

type CreateStoreOwnerParams struct {
	Name         string
	Email        string
	PasswordHash string
	Phone        sql.NullString
	Address      types.NullableAddress
}

type CreateStoreOwnerRow struct {
	StoreOwnerID int64
	Name         string
	Email        string
	CreatedAt    sql.NullTime
}

func (q *Queries) CreateStoreOwner(ctx context.Context, arg CreateStoreOwnerParams) (CreateStoreOwnerRow, error) {
	row := q.db.QueryRowContext(ctx, createStoreOwner,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.Phone,
		arg.Address,
	)
	var i CreateStoreOwnerRow
	err := row.Scan(
		&i.StoreOwnerID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}

const getCartBySession = `-- name: GetCartBySession :one
SELECT c.cart_id, c.store_id, c.updated_at
FROM cart c
JOIN visitor_session s ON s.customer_id = c.customer_id
WHERE s.session_id = $1
  AND c.store_id = $2
LIMIT 1
`

type GetCartBySessionParams struct {
	SessionID uuid.UUID
	StoreID   int64
}

type GetCartBySessionRow struct {
	CartID    int64
	StoreID   int64
	UpdatedAt sql.NullTime
}

func (q *Queries) GetCartBySession(ctx context.Context, arg GetCartBySessionParams) (GetCartBySessionRow, error) {
	row := q.db.QueryRowContext(ctx, getCartBySession, arg.SessionID, arg.StoreID)
	var i GetCartBySessionRow
	err := row.Scan(&i.CartID, &i.StoreID, &i.UpdatedAt)
	return i, err
}

const getCartItems = `-- name: GetCartItems :many
SELECT
	ci.cart_item_id,
	ci.variant_id,
	p.product_id,
	p.name AS product_name,
	v.sku,
	v.primary_image_url,
	ci.unit_price,
	ci.quantity,
	(ci.unit_price * ci.quantity)::NUMERIC AS subtotal
FROM cart_item ci
JOIN product_variant v ON v.variant_id = ci.variant_id
JOIN product p ON p.product_id = v.product_id
WHERE ci.cart_id = $1
ORDER BY ci.created_at
`

type GetCartItemsRow struct {
	CartItemID      int64
	VariantID       int64
	ProductID       int64
	ProductName     string
	Sku             string
	PrimaryImageUrl string
	UnitPrice       string
	Quantity        int32
	Subtotal        string
}

func (q *Queries) GetCartItems(ctx context.Context, cartID int64) ([]GetCartItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCartItems, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCartItemsRow
	for rows.Next() {
		var i GetCartItemsRow
		if err := rows.Scan(
			&i.CartItemID,
			&i.VariantID,
			&i.ProductID,
			&i.ProductName,
			&i.Sku,
			&i.PrimaryImageUrl,
			&i.UnitPrice,
			&i.Quantity,
			&i.Subtotal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerByEmail = `-- name: GetCustomerByEmail :one
SELECT
  customer_id,
  store_id,
  name,
  email,
  password_hash,
  created_at
FROM customer
WHERE email = $1
  AND store_id = $2
`

type GetCustomerByEmailParams struct {
	Email   string
	StoreID int64
}

type GetCustomerByEmailRow struct {
	CustomerID   int64
	StoreID      int64
	Name         string
	Email        string
	PasswordHash string
	CreatedAt    sql.NullTime
}

func (q *Queries) GetCustomerByEmail(ctx context.Context, arg GetCustomerByEmailParams) (GetCustomerByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByEmail, arg.Email, arg.StoreID)
	var i GetCustomerByEmailRow
	err := row.Scan(
		&i.CustomerID,
		&i.StoreID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getProductBase = `-- name: GetProductBase :one
SELECT
  p.product_id,
  p.store_id,
  p.name,
  p.slug,
  p.description,
  p.brand,
  p.stock_quantity as total_stock,
  p.category_id,
  c.name as category_name,
  p.default_variant_id,
  v.price,
  p.in_stock,
  v.primary_image_url AS primary_image
FROM product p
JOIN product_variant v 
  ON v.variant_id = p.default_variant_id
JOIN category_definition c
  ON p.category_id = c.category_id
WHERE p.store_id = $1 AND p.product_id = $2 AND p.deleted_at IS NULL
`

type GetProductBaseParams struct {
	StoreID   int64
	ProductID int64
}

type GetProductBaseRow struct {
	ProductID        int64
	StoreID          int64
	Name             string
	Slug             sql.NullString
	Description      sql.NullString
	Brand            sql.NullString
	TotalStock       int32
	CategoryID       int64
	CategoryName     string
	DefaultVariantID sql.NullInt64
	Price            string
	InStock          bool
	PrimaryImage     string
}

func (q *Queries) GetProductBase(ctx context.Context, arg GetProductBaseParams) (GetProductBaseRow, error) {
	row := q.db.QueryRowContext(ctx, getProductBase, arg.StoreID, arg.ProductID)
	var i GetProductBaseRow
	err := row.Scan(
		&i.ProductID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Brand,
		&i.TotalStock,
		&i.CategoryID,
		&i.CategoryName,
		&i.DefaultVariantID,
		&i.Price,
		&i.InStock,
		&i.PrimaryImage,
	)
	return i, err
}

const getProductVariantAttributes = `-- name: GetProductVariantAttributes :many
SELECT
  ad.attribute_id,
  ad.name as attribute_name,
  vav.value as attribute_value
FROM variant_attribute_value vav
JOIN attribute_definition ad 
  ON vav.attribute_id = ad.attribute_id
WHERE vav.variant_id = $1
`

type GetProductVariantAttributesRow struct {
	AttributeID    int64
	AttributeName  string
	AttributeValue string
}

func (q *Queries) GetProductVariantAttributes(ctx context.Context, variantID int64) ([]GetProductVariantAttributesRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductVariantAttributes, variantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductVariantAttributesRow
	for rows.Next() {
		var i GetProductVariantAttributesRow
		if err := rows.Scan(&i.AttributeID, &i.AttributeName, &i.AttributeValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductVariants = `-- name: GetProductVariants :many
SELECT
  variant_id,
  product_id,
  sku,
  price,
  stock_quantity,
  primary_image_url
FROM product_variant
WHERE product_id = $1 AND deleted_at IS NULL
`

type GetProductVariantsRow struct {
	VariantID       int64
	ProductID       int64
	Sku             string
	Price           string
	StockQuantity   int32
	PrimaryImageUrl string
}

func (q *Queries) GetProductVariants(ctx context.Context, productID int64) ([]GetProductVariantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductVariants, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductVariantsRow
	for rows.Next() {
		var i GetProductVariantsRow
		if err := rows.Scan(
			&i.VariantID,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.StockQuantity,
			&i.PrimaryImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoreOwnerByEmail = `-- name: GetStoreOwnerByEmail :one
SELECT
  store_owner_id,
  name,
  email,
  password_hash,
  created_at
FROM store_owner
WHERE email = $1
`

type GetStoreOwnerByEmailRow struct {
	StoreOwnerID int64
	Name         string
	Email        string
	PasswordHash string
	CreatedAt    sql.NullTime
}

func (q *Queries) GetStoreOwnerByEmail(ctx context.Context, email string) (GetStoreOwnerByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getStoreOwnerByEmail, email)
	var i GetStoreOwnerByEmailRow
	err := row.Scan(
		&i.StoreOwnerID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getTopProductsByCategory = `-- name: GetTopProductsByCategory :many
SELECT 
  p.product_id,
  p.store_id,
  p.name,
  p.slug,
  p.description,
  p.brand,
  p.category_id,
  p.default_variant_id,
  p.stock_quantity as product_total_stock,
  v.stock_quantity as item_stock,
  v.price,
  p.in_stock,
  v.primary_image_url AS primary_image
FROM product p
JOIN product_variant v 
  ON v.variant_id = p.default_variant_id
WHERE 
  p.store_id = $1 
  AND p.category_id = $2
  AND p.in_stock = TRUE
  AND p.deleted_at IS NULL
ORDER BY 
  v.stock_quantity DESC
LIMIT $3
`

type GetTopProductsByCategoryParams struct {
	StoreID    int64
	CategoryID int64
	Limit      int32
}

type GetTopProductsByCategoryRow struct {
	ProductID         int64
	StoreID           int64
	Name              string
	Slug              sql.NullString
	Description       sql.NullString
	Brand             sql.NullString
	CategoryID        int64
	DefaultVariantID  sql.NullInt64
	ProductTotalStock int32
	ItemStock         int32
	Price             string
	InStock           bool
	PrimaryImage      string
}

func (q *Queries) GetTopProductsByCategory(ctx context.Context, arg GetTopProductsByCategoryParams) ([]GetTopProductsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopProductsByCategory, arg.StoreID, arg.CategoryID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopProductsByCategoryRow
	for rows.Next() {
		var i GetTopProductsByCategoryRow
		if err := rows.Scan(
			&i.ProductID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Brand,
			&i.CategoryID,
			&i.DefaultVariantID,
			&i.ProductTotalStock,
			&i.ItemStock,
			&i.Price,
			&i.InStock,
			&i.PrimaryImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isStoreOwner = `-- name: IsStoreOwner :one
SELECT EXISTS (
    SELECT 1
    FROM store
    WHERE store_id = $1
      AND store_owner_id = $2
)
`

type IsStoreOwnerParams struct {
	StoreID      int64
	StoreOwnerID int64
}

func (q *Queries) IsStoreOwner(ctx context.Context, arg IsStoreOwnerParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isStoreOwner, arg.StoreID, arg.StoreOwnerID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listCategoriesByStore = `-- name: ListCategoriesByStore :many
SELECT c.category_id, c.name, pc.name as parent_name
FROM store_category s
JOIN category_definition c
  ON s.category_id = c.category_id
JOIN category_definition pc
  ON c.parent_id = pc.category_id
WHERE s.store_id = $1
ORDER BY c.name
`

type ListCategoriesByStoreRow struct {
	CategoryID int64
	Name       string
	ParentName string
}

func (q *Queries) ListCategoriesByStore(ctx context.Context, storeID int64) ([]ListCategoriesByStoreRow, error) {
	rows, err := q.db.QueryContext(ctx, listCategoriesByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCategoriesByStoreRow
	for rows.Next() {
		var i ListCategoriesByStoreRow
		if err := rows.Scan(&i.CategoryID, &i.Name, &i.ParentName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveAttributeIDByName = `-- name: ResolveAttributeIDByName :one
SELECT attribute_id
FROM attribute_definition
WHERE name = $1
LIMIT 1
`

func (q *Queries) ResolveAttributeIDByName(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, resolveAttributeIDByName, name)
	var attribute_id int64
	err := row.Scan(&attribute_id)
	return attribute_id, err
}

const resolveCategoryIDByName = `-- name: ResolveCategoryIDByName :one
SELECT c.category_id
FROM category_definition c
JOIN store_category s
  ON s.category_id = c.category_id
WHERE s.store_id = $1 AND c.name = $2
LIMIT 1
`

type ResolveCategoryIDByNameParams struct {
	StoreID int64
	Name    string
}

func (q *Queries) ResolveCategoryIDByName(ctx context.Context, arg ResolveCategoryIDByNameParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, resolveCategoryIDByName, arg.StoreID, arg.Name)
	var category_id int64
	err := row.Scan(&category_id)
	return category_id, err
}
