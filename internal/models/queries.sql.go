// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package models

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const getCartBySession = `-- name: GetCartBySession :one
SELECT c.cart_id, c.store_id, c.updated_at
FROM cart c
JOIN visitor_session s ON s.customer_id = c.customer_id
WHERE s.session_id = $1
  AND c.store_id = $2
LIMIT 1
`

type GetCartBySessionParams struct {
	SessionID uuid.UUID
	StoreID   int64
}

type GetCartBySessionRow struct {
	CartID    int64
	StoreID   int64
	UpdatedAt sql.NullTime
}

func (q *Queries) GetCartBySession(ctx context.Context, arg GetCartBySessionParams) (GetCartBySessionRow, error) {
	row := q.db.QueryRowContext(ctx, getCartBySession, arg.SessionID, arg.StoreID)
	var i GetCartBySessionRow
	err := row.Scan(&i.CartID, &i.StoreID, &i.UpdatedAt)
	return i, err
}

const getCartItems = `-- name: GetCartItems :many
SELECT
	ci.cart_item_id,
	ci.variant_id,
	p.product_id,
	p.name AS product_name,
	v.sku,
	v.primary_image_url,
	ci.unit_price,
	ci.quantity,
	(ci.unit_price * ci.quantity)::NUMERIC AS subtotal
FROM cart_item ci
JOIN product_variant v ON v.variant_id = ci.variant_id
JOIN product p ON p.product_id = v.product_id
WHERE ci.cart_id = $1
ORDER BY ci.created_at
`

type GetCartItemsRow struct {
	CartItemID      int64
	VariantID       int64
	ProductID       int64
	ProductName     string
	Sku             string
	PrimaryImageUrl string
	UnitPrice       string
	Quantity        int32
	Subtotal        string
}

func (q *Queries) GetCartItems(ctx context.Context, cartID int64) ([]GetCartItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCartItems, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCartItemsRow
	for rows.Next() {
		var i GetCartItemsRow
		if err := rows.Scan(
			&i.CartItemID,
			&i.VariantID,
			&i.ProductID,
			&i.ProductName,
			&i.Sku,
			&i.PrimaryImageUrl,
			&i.UnitPrice,
			&i.Quantity,
			&i.Subtotal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductAttributes = `-- name: GetProductAttributes :many
SELECT
  ad.attribute_id,
  ad.name,
  pav.value
FROM product_attribute_value pav
JOIN attribute_definition ad 
  ON pav.attribute_id = ad.attribute_id
WHERE pav.product_id = $1
`

type GetProductAttributesRow struct {
	AttributeID int64
	Name        string
	Value       string
}

func (q *Queries) GetProductAttributes(ctx context.Context, productID int64) ([]GetProductAttributesRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductAttributes, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductAttributesRow
	for rows.Next() {
		var i GetProductAttributesRow
		if err := rows.Scan(&i.AttributeID, &i.Name, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductBase = `-- name: GetProductBase :one
SELECT
  p.product_id,
  p.store_id,
  p.name,
  p.slug,
  p.description,
  p.brand,
  p.category_id,
  p.default_variant_id,
  v.price,
  p.in_stock,
  v.primary_image_url AS primary_image
FROM product p
JOIN product_variant v 
  ON v.variant_id = p.default_variant_id
WHERE p.store_id = $1 AND p.product_id = $2 AND p.deleted_at IS NULL
`

type GetProductBaseParams struct {
	StoreID   int64
	ProductID int64
}

type GetProductBaseRow struct {
	ProductID        int64
	StoreID          int64
	Name             string
	Slug             sql.NullString
	Description      sql.NullString
	Brand            sql.NullString
	CategoryID       int64
	DefaultVariantID sql.NullInt64
	Price            string
	InStock          bool
	PrimaryImage     string
}

func (q *Queries) GetProductBase(ctx context.Context, arg GetProductBaseParams) (GetProductBaseRow, error) {
	row := q.db.QueryRowContext(ctx, getProductBase, arg.StoreID, arg.ProductID)
	var i GetProductBaseRow
	err := row.Scan(
		&i.ProductID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Brand,
		&i.CategoryID,
		&i.DefaultVariantID,
		&i.Price,
		&i.InStock,
		&i.PrimaryImage,
	)
	return i, err
}

const getProductVariants = `-- name: GetProductVariants :many
SELECT
  variant_id,
  product_id,
  sku,
  price,
  stock_quantity,
  primary_image_url
FROM product_variant
WHERE product_id = $1 AND deleted_at IS NULL
`

type GetProductVariantsRow struct {
	VariantID       int64
	ProductID       int64
	Sku             string
	Price           string
	StockQuantity   int32
	PrimaryImageUrl string
}

func (q *Queries) GetProductVariants(ctx context.Context, productID int64) ([]GetProductVariantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductVariants, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductVariantsRow
	for rows.Next() {
		var i GetProductVariantsRow
		if err := rows.Scan(
			&i.VariantID,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.StockQuantity,
			&i.PrimaryImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopProductsByCategory = `-- name: GetTopProductsByCategory :many
SELECT 
  p.product_id,
  p.store_id,
  p.name,
  p.slug,
  p.description,
  p.brand,
  p.category_id,
  p.default_variant_id,
  v.price,
  p.in_stock,
  v.primary_image_url AS primary_image
FROM product p
JOIN product_variant v 
  ON v.variant_id = p.default_variant_id
WHERE 
  p.store_id = $1 
  AND p.category_id = $2
  AND p.deleted_at IS NULL
ORDER BY 
  v.stock_quantity DESC
LIMIT $3
`

type GetTopProductsByCategoryParams struct {
	StoreID    int64
	CategoryID int64
	Limit      int32
}

type GetTopProductsByCategoryRow struct {
	ProductID        int64
	StoreID          int64
	Name             string
	Slug             sql.NullString
	Description      sql.NullString
	Brand            sql.NullString
	CategoryID       int64
	DefaultVariantID sql.NullInt64
	Price            string
	InStock          bool
	PrimaryImage     string
}

func (q *Queries) GetTopProductsByCategory(ctx context.Context, arg GetTopProductsByCategoryParams) ([]GetTopProductsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopProductsByCategory, arg.StoreID, arg.CategoryID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopProductsByCategoryRow
	for rows.Next() {
		var i GetTopProductsByCategoryRow
		if err := rows.Scan(
			&i.ProductID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Brand,
			&i.CategoryID,
			&i.DefaultVariantID,
			&i.Price,
			&i.InStock,
			&i.PrimaryImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantOptions = `-- name: GetVariantOptions :many
SELECT
  vo.variant_id,
  ot.name AS option_type,
  ov.value AS option_value
FROM variant_option vo
JOIN option_value ov ON vo.option_value_id = ov.option_value_id
JOIN option_type ot ON ov.option_type_id = ot.option_type_id
WHERE vo.variant_id = $1
`

type GetVariantOptionsRow struct {
	VariantID   int64
	OptionType  string
	OptionValue string
}

func (q *Queries) GetVariantOptions(ctx context.Context, variantID int64) ([]GetVariantOptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getVariantOptions, variantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVariantOptionsRow
	for rows.Next() {
		var i GetVariantOptionsRow
		if err := rows.Scan(&i.VariantID, &i.OptionType, &i.OptionValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoriesByStore = `-- name: ListCategoriesByStore :many
SELECT category_id, store_id, name, parent_id, created_at
FROM product_category
WHERE store_id = $1
ORDER BY name
`

func (q *Queries) ListCategoriesByStore(ctx context.Context, storeID int64) ([]ProductCategory, error) {
	rows, err := q.db.QueryContext(ctx, listCategoriesByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductCategory
	for rows.Next() {
		var i ProductCategory
		if err := rows.Scan(
			&i.CategoryID,
			&i.StoreID,
			&i.Name,
			&i.ParentID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveAttributeIDByName = `-- name: ResolveAttributeIDByName :one
SELECT attribute_id
FROM attribute_definition
WHERE store_id = $1 AND name = $2
LIMIT 1
`

type ResolveAttributeIDByNameParams struct {
	StoreID int64
	Name    string
}

func (q *Queries) ResolveAttributeIDByName(ctx context.Context, arg ResolveAttributeIDByNameParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, resolveAttributeIDByName, arg.StoreID, arg.Name)
	var attribute_id int64
	err := row.Scan(&attribute_id)
	return attribute_id, err
}

const resolveCategoryIDByName = `-- name: ResolveCategoryIDByName :one
SELECT category_id
FROM product_category
WHERE store_id = $1 AND name = $2
LIMIT 1
`

type ResolveCategoryIDByNameParams struct {
	StoreID int64
	Name    string
}

func (q *Queries) ResolveCategoryIDByName(ctx context.Context, arg ResolveCategoryIDByNameParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, resolveCategoryIDByName, arg.StoreID, arg.Name)
	var category_id int64
	err := row.Scan(&category_id)
	return category_id, err
}
